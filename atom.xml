<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向往的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-12T02:36:55.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>向往</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>new对象的过程</title>
    <link href="http://example.com/2021/03/09/JVM%E4%B9%8Bnew%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/03/09/JVM%E4%B9%8Bnew%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-03-09T05:00:00.000Z</published>
    <updated>2021-04-12T02:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="new的时候发生了什么"><a href="#new的时候发生了什么" class="headerlink" title="new的时候发生了什么"></a>new的时候发生了什么</h2><span id="more"></span><p>直接上图：<br><img src="https://img-blog.csdnimg.cn/20190918224236461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>虚拟机遇到⼀条new指令时，⾸先检查这个对应的类能否在常量池中定位到⼀个类的符号引⽤。</li><li>判断这个类是否已被加载、解析和初始化</li><li>为这个新⽣对象在Java堆中分配内存空间，其中Java堆分配内存空间的⽅式主要有以下两种：<br>  <img src="https://img-blog.csdnimg.cn/2019091822432676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  1、指针碰撞<br>  分配内存空间包括开辟⼀块内存和移动指针两个步骤。<br> ⾮原⼦步骤可能出现并发问题，Java虚拟机采⽤CAS配上失败重试的⽅式保证更新。<br> 2、空闲列表<br>分配内存空间包括开辟⼀块内存和修改空闲列表两个步骤。<br>⾮原⼦步骤可能出现并发问题，Java虚拟机采⽤CAS配上失败重试的⽅式保证更新。</li><li>将分配到的内存空间都初始化为零值</li><li>设置对象头相关数据，主要包括元数据信息、GC分代年龄、对象hash</li><li>执⾏对象⽅法,初始化赋值。</li></ul><h2 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h2><p><img src="https://img-blog.csdnimg.cn/20190918224738180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h2><p>当我们在堆上创建⼀个对象实例后，就要通过虚拟机栈中的reference类型数据来操作堆上的对<br>象。现在主流的访问⽅式有两种（HotSpot虚拟机采⽤的是第⼆种）：</p><ul><li>使⽤句柄访问对象。即reference中存储的是对象句柄的地址，⽽句柄中包含了对象实例数据<br>与类型数据的具体地址信息，相当于⼆级指针。</li><li>直接指针访问对象。即reference中存储的就是对象地址，相当于⼀级指针。<br><img src="https://img-blog.csdnimg.cn/20190918225057190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20190918225123278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>两种方式对比：</li><li>垃圾回收分析：句柄⽅式当垃圾回收移动对象时，reference中存储的地址是稳定的地址，不需<br>要修改，仅需要修改对象句柄的地址；指针方式需要修改reference中存储的地址。</li><li>访问效率分析：指针方式比句柄方式快。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;new的时候发生了什么&quot;&gt;&lt;a href=&quot;#new的时候发生了什么&quot; class=&quot;headerlink&quot; title=&quot;new的时候发生了什么&quot;&gt;&lt;/a&gt;new的时候发生了什么&lt;/h2&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记</title>
    <link href="http://example.com/2021/03/08/20200225-Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/03/08/20200225-Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p>Nginx是一款<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835">轻量级</a>的<a href="https://baike.baidu.com/item/Web/150564">Web</a> 服务器/<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>服务器及<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/111106">电子邮件</a>（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806">并发</a>能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、<a href="https://baike.baidu.com/item/%E4%BA%AC%E4%B8%9C/210931">京东</a>、<a href="https://baike.baidu.com/item/%E6%96%B0%E6%B5%AA/125692">新浪</a>、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%98%93/185754">网易</a>、<a href="https://baike.baidu.com/item/%E8%85%BE%E8%AE%AF/112204">腾讯</a>、<a href="https://baike.baidu.com/item/%E6%B7%98%E5%AE%9D/145661">淘宝</a>等，摘自百度百科。</p><h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><ul><li>启动命令：在/usr/local/nginx/sbin 目录下执行 ./nginx </li><li>关闭命令：在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop </li><li>重新加载命令：在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload</li></ul><h2 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h2><p>配置文件由三部分组成，分别是</p><ul><li>全局块（配置服务器整体运行的配置指令）</li><li>events块（影响服务器与用户的网络连接）</li><li>http块</li></ul><h2 id="Nginx配置实例"><a href="#Nginx配置实例" class="headerlink" title="Nginx配置实例"></a>Nginx配置实例</h2><h3 id="反向代理实例-1"><a href="#反向代理实例-1" class="headerlink" title="反向代理实例-1"></a>反向代理实例-1</h3><p>实现效果：通过访问<a href="http://www.xwhello.com跳转到本地的tomcat主页./">www.xwhello.com跳转到本地的tomcat主页。</a></p><p>首先在host文件做好域名映射，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 www.xwhello.com</span><br></pre></td></tr></table></figure><p>Nginx配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:8080</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210225220308.png"></p><h3 id="反向代理实例-2"><a href="#反向代理实例-2" class="headerlink" title="反向代理实例 -2"></a>反向代理实例 -2</h3><p>实现效果：根据访问路径的不同跳转到不同端口的服务中，访问<a href="http://localhost/xw1/xw.html%E8%B7%B3%E8%BD%AC%E5%88%B0127.0.0.1:8080,%E8%AE%BF%E9%97%AEhttp://localhost/xw2/xw.html%E8%B7%B3%E8%BD%AC%E5%88%B0127.0.0.1:8081%E3%80%82">http://localhost/xw1/xw.html跳转到127.0.0.1:8080,访问http://localhost/xw2/xw.html跳转到127.0.0.1:8081。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ &#x2F;xw1&#x2F; &#123;</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">location ~ &#x2F;xw2&#x2F; &#123;</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;localhost:8081;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>location用于匹配url</p><ul><li><p>= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p></li><li><p> ~：用于表示 uri 包含正则表达式，并且区分大小写。</p></li><li><p>~*：用于表示 uri 包含正则表达式，并且不区分大小写。</p></li><li><p> ^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。</p></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210225225515.png"></p><p>负载均衡策略：</p><ul><li>轮询（默认）</li><li>weight。weight 代表权,重默认为 1,权重越高被分配的客户端越多。</li><li>ip_hash。每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</li><li>fair。按后端服务器的响应时间来分配请求，响应时间短的优先分配。</li></ul><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210225225916.png"></p><ul><li>autoindex会自动生产索引。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nginx简介&quot;&gt;&lt;a href=&quot;#Nginx简介&quot; class=&quot;headerlink&quot; title=&quot;Nginx简介&quot;&gt;&lt;/a&gt;Nginx简介&lt;/h2&gt;&lt;p&gt;Nginx是一款&lt;a href=&quot;https://baike.baidu.com/item/%E8%</summary>
      
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习笔记-JVM运行参数篇</title>
    <link href="http://example.com/2021/03/08/20210308-JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JVM%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E7%AF%87/"/>
    <id>http://example.com/2021/03/08/20210308-JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JVM%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E7%AF%87/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM运行参数"><a href="#JVM运行参数" class="headerlink" title="JVM运行参数"></a>JVM运行参数</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM运行参数&quot;&gt;&lt;a href=&quot;#JVM运行参数&quot; class=&quot;headerlink&quot; title=&quot;JVM运行参数&quot;&gt;&lt;/a&gt;JVM运行参数&lt;/h1&gt;</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>draw.io学习培训</title>
    <link href="http://example.com/2021/03/08/20210316-draw.io%E5%AD%A6%E4%B9%A0%E5%9F%B9%E8%AE%AD/"/>
    <id>http://example.com/2021/03/08/20210316-draw.io%E5%AD%A6%E4%B9%A0%E5%9F%B9%E8%AE%AD/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-培训目的"><a href="#1-培训目的" class="headerlink" title="1. 培训目的"></a>1. 培训目的</h1><ul><li>让大家对draw.io有基本的了解，能够使用draw.io绘制常见的图形。</li><li>掌握常用的绘图技巧。</li></ul><h1 id="2-为什么使用draw-io"><a href="#2-为什么使用draw-io" class="headerlink" title="2. 为什么使用draw.io"></a>2. 为什么使用draw.io</h1><ul><li>开源免费</li><li>支持在线、离线模式</li><li>支持与其他平台进行集成</li><li>支持多种图形（流程图，思维导图，组织结构图，维恩图，信息图，网络和架构图，平面图，电气和机架图，UML图等等）</li><li>支持导出为多种格式（PNG、JPEG、SVG、PDF、<strong>VISIO</strong>、HTML、XML、URL）</li></ul><h1 id="3-draw-io简介"><a href="#3-draw-io简介" class="headerlink" title="3. draw.io简介"></a>3. draw.io简介</h1><p>  draw.io 是一款免费的在线图表编辑工具, 可以用来编辑工作流, BPM, org charts, UML, ER图, 网络拓朴图等。draw.io主界面如下图所示，主要包含菜单、工具栏、画布、图形库、格式面板五大部分组成。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D.png"></p><h1 id="4-绘图"><a href="#4-绘图" class="headerlink" title="4. 绘图"></a>4. 绘图</h1><h2 id="4-1-流程图"><a href="#4-1-流程图" class="headerlink" title="4.1 流程图"></a>4.1 流程图</h2><h3 id="4-1-1-流程图介绍"><a href="#4-1-1-流程图介绍" class="headerlink" title="4.1.1 流程图介绍"></a>4.1.1 流程图介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%B8%B8%E8%A7%81%E7%AC%A6%E5%8F%B7.png"></p><h3 id="4-1-2-流程图画图规范"><a href="#4-1-2-流程图画图规范" class="headerlink" title="4.1.2 流程图画图规范"></a>4.1.2 流程图画图规范</h3><ol><li><p>绘制流程图时，为了提高流程图的逻辑性，应遵循从左到右、从上到下的顺序排列。</p><p> <img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210317140803.png"></p></li><li><p>一个流程从开始符开始，以结束符结束。开始符号只能出现一次，而结束符号可出现多次。若流程足够清晰，可省略开始、结束符号。</p></li><li><p>菱形为判断符号，必须要有是和否(或Y和N)两种处理结果。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210317141107.png"></p></li></ol><p>​      4. 同一流程图内，符号大小需要保持一致，同时连接线不能交叉，连接线不能无故弯曲。</p><p>​      5.流程处理关系为并行关系的，需要将流程放在同一高度。</p><p>​          <img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210317141044.png">  </p><p>​     6. 必要时应采用标注，以此来清晰地说明流程，标注要用专门的标注符号。</p><p>​     7. 处理流程须以单一入口和单一出口绘制，同一路径的指示箭头应只有一个。</p><p>​        <img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210317140934.png"></p><ul><li>同一路径的指示箭头应只有一个。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210317141015.png"></p><h3 id="4-1-3-流程图示例"><a href="#4-1-3-流程图示例" class="headerlink" title="4.1.3 流程图示例"></a>4.1.3 流程图示例</h3><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E9%80%9A%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B9%8B%E8%A7%82%E5%AF%9F%E7%BF%B0%E5%8D%BF-demo.gif"></p><h2 id="4-2-思维导图"><a href="#4-2-思维导图" class="headerlink" title="4.2 思维导图"></a>4.2 思维导图</h2><h3 id="4-2-1-思维导图示例"><a href="#4-2-1-思维导图示例" class="headerlink" title="4.2.1 思维导图示例"></a>4.2.1 思维导图示例</h3><p>左侧搜索框搜索mindmap，可快速找到思维导图模板。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BEdemo.gif"></p><h2 id="4-3-架构图"><a href="#4-3-架构图" class="headerlink" title="4.3 架构图"></a>4.3 架构图</h2><h3 id="4-3-1-架构图介绍"><a href="#4-3-1-架构图介绍" class="headerlink" title="4.3.1  架构图介绍"></a>4.3.1  架构图介绍</h3><p>系统架构图是为了抽象地表示软件系统的整体轮廓和各个组件之间的相互关系和约束边界，以及软件系统的物理部署和软件系统的演进方向的整体视图。架构分类有很多，有一种比较流行的是4+1视图，分别为场景视图、逻辑视图、物理视图、处理流程视图和开发视图。</p><ol><li><p>场景视图，场景视图用于描述系统的参与者与功能用例间的关系，反映系统的最终需求和交互设计，通常由用例图表示。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210318170714.png"></p></li><li><p>逻辑视图，逻辑视图用于描述系统软件功能拆解后的组件关系，组件约束和边界，反映系统整体组成与系统如何构建的过程，通常由UML的组件图和类图来表示。【示例待补充】</p></li><li><p>物理视图，物理视图用于描述系统软件到物理硬件的映射关系，反映出系统的组件是如何部署到一组可计算机器节点上，用于指导软件系统的部署实施过程。【示例待补充】</p></li><li><p>处理流程视图，视图用于描述系统软件组件之间的通信时序，数据的输入输出，反映系统的功能流程与数据流程,通常由时序图和流程图表示。（会单独讲解）</p></li><li><p>开发视图，开发视图用于描述系统的模块划分和组成，以及细化到内部包的组成设计，服务于开发人员，反映系统开发实施过程。【示例待补充】</p></li></ol><h3 id="4-3-2-如何画好架构图"><a href="#4-3-2-如何画好架构图" class="headerlink" title="4.3.2  如何画好架构图"></a>4.3.2  如何画好架构图</h3><ol><li>明确受众（客户、运维、开发），根据不同的受众传递不同的信息。</li><li>具备一致性和足够的准确性，能够与代码相呼应。</li><li>C4模型讲解</li></ol><h3 id="4-3-3-架构图示例"><a href="#4-3-3-架构图示例" class="headerlink" title="4.3.3 架构图示例"></a>4.3.3 架构图示例</h3><p>TODO</p><h2 id="4-5-时序图"><a href="#4-5-时序图" class="headerlink" title="4.5 时序图"></a>4.5 时序图</h2><h3 id="4-5-1-时序图介绍"><a href="#4-5-1-时序图介绍" class="headerlink" title="4.5.1 时序图介绍"></a>4.5.1 时序图介绍</h3><p>时序图（Sequence Diagram） ， 亦称为序列图或循序图， 是一种 UML 行为图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。 它可以表示用例的行为顺序， 当执行一个用例行为时， 时序图中的每条消息对应了一个类操作或状态机中引起转换的触发事件。主要由以下几部分组成：</p><ul><li>对象，代表时序图中的对象在交互中所扮演的角色， 位于时序图顶部。</li><li>生命线，代表时序图中的对象在一段时期内的存在。</li><li>激活期，代表时序图中的对象执行一项操作的时期。</li><li>消息，是定义交互和协作中交换信息的类， 用于对对象间的通信内容建模， 通过互发消息来实现对象之间的交互。</li></ul><p>基本符号如下：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210317174216.png"></p><p>示例如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210317165814.png"></p><h3 id="4-5-2-时序图画图规范"><a href="#4-5-2-时序图画图规范" class="headerlink" title="4.5.2 时序图画图规范"></a>4.5.2 时序图画图规范</h3><ul><li>遵从从左到右，从上到下的画图方式</li><li>正确使用时序图相关符号，准确表达执行过程。</li></ul><h3 id="4-5-3-时序图示例"><a href="#4-5-3-时序图示例" class="headerlink" title="4.5.3 时序图示例"></a>4.5.3 时序图示例</h3><p> TODO</p><h1 id="5-补充：draw常用绘图技巧"><a href="#5-补充：draw常用绘图技巧" class="headerlink" title="5. 补充：draw常用绘图技巧"></a>5. 补充：draw常用绘图技巧</h1><ul><li>全局自动调整图形大小适配文本。先CTRL+SHIFT+I全选所有图形，然后点击自动调整,效果如下图。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E5%85%A8%E5%B1%80%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%9B%BE%E5%BD%A2%E9%80%82%E9%85%8D%E6%96%87%E6%9C%AC-1.gif"></p><ul><li><p>单个调整图形大小适配文本。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%9B%BE%E5%BD%A2%E9%80%82%E9%85%8D%E6%96%87%E6%9C%AC-11.gif"></p></li><li><p>组合的使用。一般用来将某些图形或连线组合在一起，可以快速将组合内的元素批量操作，并且会保持比例不会变化。</p></li><li><p>调整图形大小，限制比例，不会失调。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E8%B0%83%E6%95%B4%E5%9B%BE%E5%BD%A2%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E6%AF%94%E4%BE%8B.gif"></p></li><li><p>插入链接</p><p> <img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E6%8F%92%E5%85%A5%E9%93%BE%E6%8E%A5.gif"></p></li><li><p>调整文字方向。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E8%B0%83%E6%95%B4%E6%96%87%E5%AD%97%E6%96%B9%E5%90%91-1.gif"></p></li><li><p>控制图片只能水平或垂直移动，按紧SHIFT键对图形进行拖动。</p><p> <img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E6%8E%A7%E5%88%B6%E5%9B%BE%E7%89%87%E5%8F%AA%E8%83%BD%E6%B0%B4%E5%B9%B3%E6%88%96%E5%9E%82%E7%9B%B4%E7%A7%BB%E5%8A%A8+shift.gif"></p></li><li><p>嵌入html。</p><p> <img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E5%B5%8C%E5%85%A5html%E4%B8%AD.gif"></p></li><li><p>删除图形及其关联的连接，按住CTRL键点击删除。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E5%88%A0%E9%99%A4%E5%9B%BE%E5%BD%A2%E5%8F%8A%E5%85%B3%E8%81%94%E7%9A%84%E8%BF%9E%E6%8E%A5.gif"></p></li><li><p>改变图形形状。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E6%94%B9%E5%8F%98%E5%9B%BE%E5%BD%A2.gif"></p></li><li><p>便笺本的使用。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E4%BE%BF%E7%AC%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8.gif"></p></li><li><p>图形导出。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/%E5%9B%BE%E7%89%87%E5%AF%BC%E5%87%BA-%E4%BB%A5pdf%E4%B8%BA%E4%BE%8B.gif"></p></li><li><p>待补充</p></li><li><p>快捷键,如下图所示。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/shortcuts%20(1).jpg" alt="drawo.io快捷键"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://www.woshipm.com/zhichang/2329530.html">画了多年的流程图，你真的画规范了吗？</a></li><li><a href="https://www.youtube.com/channel/UCiTtRN9b8P4CoSfpkfgEJHA">youtube官方教程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;1-培训目的&quot;&gt;&lt;a href=&quot;#1-培训目的&quot; class=&quot;headerlink&quot; title=&quot;1. 培训目的&quot;&gt;&lt;/a&gt;1. 培训目的&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;让大家对draw.io有基本的了解，能够使用draw.io绘制常见</summary>
      
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    
    <category term="draw.io" scheme="http://example.com/tags/draw-io/"/>
    
  </entry>
  
  <entry>
    <title>ARM jdk1.8镜像制作</title>
    <link href="http://example.com/2021/03/08/ARM%20jdk1.8%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"/>
    <id>http://example.com/2021/03/08/ARM%20jdk1.8%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-06-13T14:49:48.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARM-jdk1-8镜像制作"><a href="#ARM-jdk1-8镜像制作" class="headerlink" title="ARM jdk1.8镜像制作"></a>ARM jdk1.8镜像制作</h3><ul><li><p>首先找一个centos7的基础镜像，并肩jdk安装包复制进去。启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name&#x3D;mycentos centos</span><br><span class="line"></span><br><span class="line">docker cp &#x2F;data&#x2F;yl&#x2F;arm_centos_jdk1.8&#x2F;jdk-8u151-linux-arm64-vfp-hflt.tar.gz mycentos:&#x2F;usr&#x2F;local</span><br></pre></td></tr></table></figure><p>进入容器解压。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf jdk-8u151-linux-arm64-vfp-hflt.tar.gz</span><br></pre></td></tr></table></figure><p>编辑/etc/profile文件，在最后加入（如果是在Dockerfile中，\变量前加占位符）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_151</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure><p>刷新配置文件 source /etc/profile,使用java -version命令验证是否安装成功，将正在运行的容器打包成一个新的镜像。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ARM-jdk1-8镜像制作&quot;&gt;&lt;a href=&quot;#ARM-jdk1-8镜像制作&quot; class=&quot;headerlink&quot; title=&quot;ARM jdk1.8镜像制作&quot;&gt;&lt;/a&gt;ARM jdk1.8镜像制作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先找一个centos7的</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 简介及安装</title>
    <link href="http://example.com/2021/03/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2021/03/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-简介及安装"><a href="#Docker-简介及安装" class="headerlink" title="Docker 简介及安装"></a>Docker 简介及安装</h1><span id="more"></span><h2 id="docker-是什么"><a href="#docker-是什么" class="headerlink" title="docker 是什么"></a>docker 是什么</h2><p>Docker 是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。<br>总结：</p><ol><li><p>docker 是一个开源的软件部署解决方案</p></li><li><p>docker 也是轻量级的应用容器框架</p></li><li><p>docker 可以打包、发布、运行任何的应用</p><blockquote></blockquote></li></ol><h2 id="docker-使用场景"><a href="#docker-使用场景" class="headerlink" title="docker 使用场景"></a>docker 使用场景</h2><p>docker 在 devops 体系、微服务应用中的地位至关重要，使用场景有：</p><ol><li>应用自动化打包、发布</li><li>自动化测试和持续集成、发布</li><li>微服务快速扩容伸缩</li></ol><h2 id="docker-优点"><a href="#docker-优点" class="headerlink" title="docker 优点"></a>docker 优点</h2><ul><li><p>跨平台可移植性：按统一标准打包（镜像中），可传播。</p></li><li><p>面向应用：优化部署应用（设计哲学）→ API，接口及文档（体现）。</p></li><li><p>版本控制：追踪、查询、记录版本信息（应用程序更改史）和回滚版本等</p></li><li><p>组件复用：组件式搭建（基础镜像）→ Python(运行环境) | postgreasql(基础镜像)。</p></li><li><p>共享性：公共的注册服务器（可免费下载源码）。</p></li></ul><h2 id="docker-与-VM-比较"><a href="#docker-与-VM-比较" class="headerlink" title="docker 与 VM 比较"></a>docker 与 VM 比较</h2><p>在这里引用 docker 官网文档的一组图片来比较一下 docker 和 VM 之间的区别。容器是应用层的抽象，它将代码和依赖关系打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。容器占用的空间比 VM 少（容器映像的大小通常为几十 MB），启动速度也比 VM 快很多，可以处理更多的应用程序，并且需要更少的 VM 和操作系统。虚拟机（VM）是物理硬件的抽象，将一台服务器转变为多台服务器。管理程序允许多台 VM 在单台机器上运行。每个 VM 都包含操作系统的完整副本，应用程序，必要的二进制文件和库，一般占用数十 GB。</p><p><img src="https://img-blog.csdnimg.cn/20190901115216951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="虚拟机"></p><p><img src="https://img-blog.csdnimg.cn/20190901115244953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="CentOS-安装-docker"><a href="#CentOS-安装-docker" class="headerlink" title="CentOS 安装 docker"></a>CentOS 安装 docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装docker</span><br><span class="line">yum install docker-io -y</span><br><span class="line">#启动docker</span><br><span class="line">service docker start  或者 systemctl start docker</span><br><span class="line">#设置开启自启动</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">#查看是否启动成功</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p>有 client 和 service 两部分表示 docker 安装启动都成功了<br><img src="https://img-blog.csdnimg.cn/20190901120617587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至此，docker 已经安装启动完成。</p><h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看镜像</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY：表示镜像的仓库源</span><br><span class="line">TAG：镜像的标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190901121200442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看正在运行的容器</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190901120956566.png" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#docker拉取镜像</span><br><span class="line">docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019090112150615.png" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#docker查找镜像</span><br><span class="line">docker search httpd</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190901121753913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#启动镜像</span><br><span class="line">docker run -d --privileged&#x3D;true -p 6380:6379 -v &#x2F;usr&#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis-6380.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;usr&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data --name redistslave-3 857c4ab5f029 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes</span><br><span class="line">参数详解：</span><br><span class="line">--privileged&#x3D;true  容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限</span><br><span class="line">-v&#x2F;usr&#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis-6379.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf 映射配置文件</span><br><span class="line">redis-server &#x2F;etc&#x2F;redis&#x2F;redis-6381.conf 配置文件方式启动</span><br><span class="line">--appendonly yes 数据持久化</span><br><span class="line"></span><br><span class="line">#重启镜像</span><br><span class="line">docker restart CONTAINER ID</span><br></pre></td></tr></table></figure><h2 id="docker-加速"><a href="#docker-加速" class="headerlink" title="docker 加速"></a>docker 加速</h2><p>由于 docker 拉取镜像默认使用的官网仓库，需要翻墙，速度会比较慢，可以使用阿里云进行加速。</p><ol><li>进入阿里云容器镜像服务<br><img src="https://img-blog.csdnimg.cn/201909011228351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、使用加速服务<br><img src="https://img-blog.csdnimg.cn/20190901122942252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;your address&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="实战-docker-部署-MySQL"><a href="#实战-docker-部署-MySQL" class="headerlink" title="实战-docker 部署 MySQL"></a>实战-docker 部署 MySQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#拉取镜像</span><br><span class="line">docker pull mysql:5.6</span><br><span class="line">#启动</span><br><span class="line">docker run -p 3306:3306 --name mymysql -v $PWD&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -v $PWD&#x2F;logs:&#x2F;logs -v $PWD&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:5.6</span><br><span class="line">-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。</span><br><span class="line"></span><br><span class="line">-v $PWD&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d：将主机当前目录下的 conf&#x2F;my.cnf 挂载到容器的 &#x2F;etc&#x2F;mysql&#x2F;my.cnf。</span><br><span class="line"></span><br><span class="line">-v $PWD&#x2F;logs:&#x2F;logs：将主机当前目录下的 logs 目录挂载到容器的 &#x2F;logs。</span><br><span class="line"></span><br><span class="line">-v $PWD&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql ：将主机当前目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 。</span><br><span class="line"></span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456：初始化 root 用户的密码。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190901123510371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjgwMTM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至此，MySQL 启动成功。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-简介及安装&quot;&gt;&lt;a href=&quot;#Docker-简介及安装&quot; class=&quot;headerlink&quot; title=&quot;Docker 简介及安装&quot;&gt;&lt;/a&gt;Docker 简介及安装&lt;/h1&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="http://example.com/2021/03/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/03/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><span id="more"></span><ul><li>构建容器：docker run -itd –name=mycentos centos:7<br>-i ：表示以交互模式运行容器（让容器的标准输入保持打开）<br>-d：表示后台运行容器，并返回容器 ID<br>-t：为容器重新分配一个伪输入终端<br>–name：为容器指定名称</li><li>停止容器：docker stop CONTAINER_ID / CONTAINER_NAME</li><li>查看本地所有的容器：docker ps -a</li><li>启动容器：docker start CONTAINER_ID / CONTAINER_NAME</li><li>重启容器：docker restart CONTAINER_ID / CONTAINER_NAME</li><li>删除容器：docker rm CONTAINER_ID / CONTAINER_NAME</li><li>强制删除容器：docker rmi -f CONTAINER_ID / CONTAINER_NAME</li><li>查看容器详细信息：docker inspect CONTAINER_ID / CONTAINER_NAME</li><li>进入容器：docker exec -it 0ad5d7b2c3a4 /bin/bash</li><li>一次性停止所有容器：docker stop $(docker ps -a q)</li><li>从宿主机复制到容器：docker cp 宿主机本地路径 容器名字/ID：容器路径</li><li>docker cp 容器名字/ID：容器路径 宿主机本地路径</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;常见命令&quot;&gt;&lt;a href=&quot;#常见命令&quot; class=&quot;headerlink&quot; title=&quot;常见命令&quot;&gt;&lt;/a&gt;常见命令&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-compose</title>
    <link href="http://example.com/2021/03/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9BDockercompose%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/03/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9BDockercompose%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>docker-compose：是一个用于定义和运行多容器 Docker 的应用程序工具，可以帮助我们可以轻松、高效的管<br>理容器</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装 pip 工具```<br>yum install -y epel-release</p><p>yum install -y python-pip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>安装 docker-compose```<br>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> docker-compose==1.24.1</p><p>#查看安装版本<br>docker-compose version</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先编写一个最简单的 docker-compose.yml,代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">   grafana:</span><br><span class="line">     image: grafana&#x2F;grafana</span><br><span class="line">~</span><br></pre></td></tr></table></figure><p>docker-compose 常见命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 后台启动容器</span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">#查看容器运行情况</span><br><span class="line">docker-compose ps</span><br><span class="line"></span><br><span class="line">#停止并删除容器</span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line">#停止并删除容器并删除volume</span><br><span class="line">docker-compose down --volumes</span><br><span class="line"></span><br><span class="line"># 停止启动容器</span><br><span class="line">docker-compose start</span><br><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><p>附一个模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line">services:</span><br><span class="line">    gogs:</span><br><span class="line">      container_name: gogs_it513</span><br><span class="line">      image: &#39;gogs&#x2F;gogs:latest&#39;</span><br><span class="line">      ports:</span><br><span class="line">        - &quot;20022:20022&quot;</span><br><span class="line">        - &quot;23000:3000&quot;</span><br><span class="line">      volumes:</span><br><span class="line">        - &#x2F;volume3&#x2F;docker&#x2F;gogs&#x2F;data:&#x2F;data</span><br><span class="line">        - &#x2F;volume3&#x2F;docker&#x2F;gogs&#x2F;app:&#x2F;app</span><br><span class="line">      networks:</span><br><span class="line">        web:</span><br><span class="line">          ipv4_address: 192.168.2.1</span><br><span class="line">      dns: 192.168.1.1</span><br><span class="line">      environment:</span><br><span class="line">        TZ: &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">      restart: always</span><br><span class="line">    mysql:</span><br><span class="line">      container_name: mysql_it513</span><br><span class="line">      image: &#39;mysql:5.7.25&#39;</span><br><span class="line">      ports:</span><br><span class="line">        - &quot;23306:3306&quot;</span><br><span class="line">      volumes:</span><br><span class="line">        - &#x2F;volume3&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">        - &#x2F;volume3&#x2F;docker&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql</span><br><span class="line">      networks:</span><br><span class="line">        web:</span><br><span class="line">          ipv4_address: 192.168.2.2</span><br><span class="line">      environment:</span><br><span class="line">        MYSQL_ROOT_PASSWORD: mysql@it513</span><br><span class="line">        TZ: &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">      restart: always</span><br><span class="line">networks:</span><br><span class="line">  web:</span><br><span class="line">    driver: &#39;bridge&#39;</span><br><span class="line">    ipam:</span><br><span class="line">      config:</span><br><span class="line">        - subnet: 192.168.2.0&#x2F;24</span><br><span class="line">          gateway: 192.168.2.254</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;docker-compose：是一个用于定义和运行多容器 Docker 的应用程序工具，可以帮助我们可以轻松、高效的管&lt;br&gt;理容器&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker构建镜像</title>
    <link href="http://example.com/2021/03/08/Dokcer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F/"/>
    <id>http://example.com/2021/03/08/Dokcer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="镜像定义"><a href="#镜像定义" class="headerlink" title="镜像定义"></a>镜像定义</h2><span id="more"></span><p>Docker 镜像是由文件系统叠加而成，最底端是一个文件引导系统，即 bootfs。除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。例图如下。</p><p><img src="https://img.hacpai.com/file/2020/01/image-94620985.png"></p><h2 id="2-构建镜像"><a href="#2-构建镜像" class="headerlink" title="2.构建镜像"></a>2.构建镜像</h2><p>构建镜像主要有两种方法：</p><ul><li>使用 docker commit 命令</li><li>使用 docker build 和 Dockerfile 命令</li></ul><p>推荐使用 Dockerfile 构建镜像，因为 Dockerfile 更加灵活、强大。</p><h3 id="1-使用-Docker-的-commit-命令创建镜像"><a href="#1-使用-Docker-的-commit-命令创建镜像" class="headerlink" title="1.使用 Docker 的 commit 命令创建镜像"></a>1.使用 Docker 的 commit 命令创建镜像</h3><p>Docker 的 comiit 命令有点类似于 SVN、Git,先创建一个 容器，然后对容器进行修改，然后提交成为一个新镜像。</p><p>首先，基于 Ubuntu 容器创建一个新镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos:7 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2020/01/image-12d8fa48.png"></p><p>在/home 路径下创建 xw 文件夹：mkdir /home/xw</p><p><img src="https://img.hacpai.com/file/2020/01/image-aa0ed6c6.png"></p><p>安装 ifconfig 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install net-tools</span><br></pre></td></tr></table></figure><p>提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a</span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2020/01/image-1e80af08.png"></p><p>使用 docker images 命令可以看到我们新构建的镜像。</p><p><img src="https://img.hacpai.com/file/2020/01/image-00419355.png"></p><p>启动新构建的镜像，看下我们创建的目录是否存在。</p><p><img src="https://img.hacpai.com/file/2020/01/image-09041e63.png"></p><p>镜像文件存在，说明构建的镜像是 OK 的。</p><h3 id="3-使用-Dockerfile-构建镜像"><a href="#3-使用-Dockerfile-构建镜像" class="headerlink" title="3.使用 Dockerfile 构建镜像"></a>3.使用 Dockerfile 构建镜像</h3><p>Dockerfile 使用 DSL 语法编写构建镜像的命令，使用 docker build 命令构建镜像。</p><p>首先，先了解一下相关命令。</p><ul><li>MAINTAINER 注明作者</li><li>COPY 复制文件进入镜像（只能用相对路径，不能用绝对路径）</li><li>ENV 设置环境变量</li><li>EXPOSE 暴露容器端口</li><li>RUN  在构建镜像的时候执行，作用于镜像层面</li><li>CMD 在容器启动的时候执行，作用于容器层，dockerfile 里有多条时只允许执行最后一条。(需要运行的命令在数组里面，如果不使用数组指定 CMD 命令，这时 Docker 会在命令前面加上/bin/sh -c,可能会导致不可预计的错误，所以 Docker 推荐一般使用数组形式执行命令)</li><li>ENTRYPOINT 在容器启动的时候执行，作用于容器层，dockerfile 里有多条时只允许执行最后一条</li><li>ADD   复制文件进入镜像（假如文件是.tar.gz 文件会解压）</li><li>WORKDIR 指定工作目录，假如路径不存在会创建路径</li></ul><p>我们创建一个最简单的 Dockerfile,内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from centos:7</span><br><span class="line">run cd &#x2F;home</span><br><span class="line">run mkdir xw</span><br><span class="line">run echo &quot;mkdir xw dir&quot;</span><br><span class="line">run ls</span><br></pre></td></tr></table></figure><p>使用 docker -build 命令构建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t  mycentos7:1 .</span><br></pre></td></tr></table></figure><p>-t 指定 tag,如果我们没有指定 tag,默认使用 latest 标签。打包完成后使用 docker images 命令查看我们构建的镜像。</p><p><img src="https://img.hacpai.com/file/2020/01/image-c08714ed.png"></p><p>由于 Dockerfile 每一个步骤的执行结果都会提交成镜像，它会将之前构建的镜像作为缓存，大大加快构建的速度，如果不需要缓存，可以添加 –no-cache 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t mycentos:2 .</span><br></pre></td></tr></table></figure><h2 id="3-镜像推送到-Docker-Hub"><a href="#3-镜像推送到-Docker-Hub" class="headerlink" title="3.镜像推送到 Docker Hub"></a>3.镜像推送到 Docker Hub</h2><p>首先注册一个 docker Hub 账号。使用 docker login 命令，登录</p><p><img src="https://img.hacpai.com/file/2020/01/image-95b927a5.png"></p><p>开始推送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push mycentos7</span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2020/01/image-6f96c40b.png"></p><p>镜像名称不符合规范，重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag cea9577866a5 docker.io&#x2F;2457081614&#x2F;mycentos7</span><br></pre></td></tr></table></figure><p>重新推送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push docker.io&#x2F;2457081614&#x2F;mycentos7</span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2020/01/image-47fd087d.png"><img src="https://img.hacpai.com/file/2020/01/image-b91d53df.png"></p><p>推送成功。</p><p>加油，共勉。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;镜像定义&quot;&gt;&lt;a href=&quot;#镜像定义&quot; class=&quot;headerlink&quot; title=&quot;镜像定义&quot;&gt;&lt;/a&gt;镜像定义&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记（未完善）</title>
    <link href="http://example.com/2021/03/08/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/03/08/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x1-Elasticsearch概念"><a href="#0x1-Elasticsearch概念" class="headerlink" title="0x1 Elasticsearch概念"></a>0x1 Elasticsearch概念</h2><span id="more"></span><ul><li>索引</li></ul><h2 id="0x2-Elasticsearch使用基本命令"><a href="#0x2-Elasticsearch使用基本命令" class="headerlink" title="0x2 Elasticsearch使用基本命令"></a>0x2 Elasticsearch使用基本命令</h2><p>Elasticsearch是基于Restful风格进行设计的，我们可以使用Http请求操作Elasticssearch。</p><h3 id="1-索引基本命令"><a href="#1-索引基本命令" class="headerlink" title="1. 索引基本命令"></a>1. 索引基本命令</h3><ul><li><p>创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 创建索引</span><br><span class="line">PUT localhost:9200&#x2F;nba </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;acknowledged&quot;: true,</span><br><span class="line">    &quot;shards_acknowledged&quot;: true,</span><br><span class="line">    &quot;index&quot;: &quot;nba&quot;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>获取索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET localhost:9200&#x2F;nba</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;nba&quot;: &#123;</span><br><span class="line">        &quot;aliases&quot;: &#123;&#125;,</span><br><span class="line">        &quot;mappings&quot;: &#123;&#125;,</span><br><span class="line">        &quot;settings&quot;: &#123;</span><br><span class="line">            &quot;index&quot;: &#123;</span><br><span class="line">                &quot;creation_date&quot;: &quot;1589206816630&quot;,</span><br><span class="line">                &quot;number_of_shards&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;uuid&quot;: &quot;2u-wlpkKSoaIhp8h9Biqmg&quot;,</span><br><span class="line">                &quot;version&quot;: &#123;</span><br><span class="line">                    &quot;created&quot;: &quot;7020199&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;provided_name&quot;: &quot;nba&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELETE localhost:9200&#x2F;nba</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;acknowledged&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>批量获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PUT localhost:9200&#x2F;cba</span><br><span class="line">PUT localhost:9200&#x2F;nba</span><br><span class="line"></span><br><span class="line">## 批量获取，用逗号隔开</span><br><span class="line">GET localhost:9200&#x2F;cba,nba</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;cba&quot;: &#123;</span><br><span class="line">        &quot;aliases&quot;: &#123;&#125;,</span><br><span class="line">        &quot;mappings&quot;: &#123;&#125;,</span><br><span class="line">        &quot;settings&quot;: &#123;</span><br><span class="line">            &quot;index&quot;: &#123;</span><br><span class="line">                &quot;creation_date&quot;: &quot;1589208603245&quot;,</span><br><span class="line">                &quot;number_of_shards&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;uuid&quot;: &quot;cuW6GYutR-Sat5vPtMiWCA&quot;,</span><br><span class="line">                &quot;version&quot;: &#123;</span><br><span class="line">                    &quot;created&quot;: &quot;7020199&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;provided_name&quot;: &quot;cba&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nba&quot;: &#123;</span><br><span class="line">        &quot;aliases&quot;: &#123;&#125;,</span><br><span class="line">        &quot;mappings&quot;: &#123;&#125;,</span><br><span class="line">        &quot;settings&quot;: &#123;</span><br><span class="line">            &quot;index&quot;: &#123;</span><br><span class="line">                &quot;creation_date&quot;: &quot;1589208584555&quot;,</span><br><span class="line">                &quot;number_of_shards&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;uuid&quot;: &quot;dkBxRSTNTzCasgi_f67F3g&quot;,</span><br><span class="line">                &quot;version&quot;: &#123;</span><br><span class="line">                    &quot;created&quot;: &quot;7020199&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;provided_name&quot;: &quot;nba&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>获取所有索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GET localhost:9200&#x2F;_all</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;cba&quot;: &#123;</span><br><span class="line">        &quot;aliases&quot;: &#123;&#125;,</span><br><span class="line">        &quot;mappings&quot;: &#123;&#125;,</span><br><span class="line">        &quot;settings&quot;: &#123;</span><br><span class="line">            &quot;index&quot;: &#123;</span><br><span class="line">                &quot;creation_date&quot;: &quot;1589208603245&quot;,</span><br><span class="line">                &quot;number_of_shards&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;uuid&quot;: &quot;cuW6GYutR-Sat5vPtMiWCA&quot;,</span><br><span class="line">                &quot;version&quot;: &#123;</span><br><span class="line">                    &quot;created&quot;: &quot;7020199&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;provided_name&quot;: &quot;cba&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nba&quot;: &#123;</span><br><span class="line">        &quot;aliases&quot;: &#123;&#125;,</span><br><span class="line">        &quot;mappings&quot;: &#123;&#125;,</span><br><span class="line">        &quot;settings&quot;: &#123;</span><br><span class="line">            &quot;index&quot;: &#123;</span><br><span class="line">                &quot;creation_date&quot;: &quot;1589208584555&quot;,</span><br><span class="line">                &quot;number_of_shards&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;uuid&quot;: &quot;dkBxRSTNTzCasgi_f67F3g&quot;,</span><br><span class="line">                &quot;version&quot;: &#123;</span><br><span class="line">                    &quot;created&quot;: &quot;7020199&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;provided_name&quot;: &quot;nba&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST localhost:9200&#x2F;nba&#x2F;_close</span><br></pre></td></tr></table></figure></li><li><p>打开索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:9200&#x2F;nba&#x2F;_open</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-映射基本命令"><a href="#2-映射基本命令" class="headerlink" title="2.映射基本命令"></a>2.映射基本命令</h3><p>mapping用于定义索引的结构。</p><ul><li>添加mapping<img src="https://img.hacpai.com/file/2020/05/image-620fd808.png" alt="image.png"></li><li>获取mapping   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET localhost:9200&#x2F;nba&#x2F;_mapping</span><br></pre></td></tr></table></figure></li><li>修改mapping,与新增相似，post请求</li></ul><h3 id="3-文档基本命令"><a href="#3-文档基本命令" class="headerlink" title="3.文档基本命令"></a>3.文档基本命令</h3><ul><li>新增文档<br><img src="https://img.hacpai.com/file/2020/05/image-958b16e0.png" alt="image.png"> <strong>PS: 当我们指定ID时使用put请求，不指定ID使用post请求；当索引不存在时，如果打开了自动创建索引开关，会自动创建索引</strong><ul><li>⾃动创建索引<br>  查看auto_create_index开关状态，请求<a href="http://localhost:9200/_cluster/settings">http://localhost:9200/_cluster/settings</a> ，当索引不存在并且auto_create_index为true的时候，新增⽂档时会⾃动创建索引，修改auto_create_index状态。<br>PUT localhost:9200/_cluster/settings</li></ul></li><li>新增文档指定操作类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT localhost:9200&#x2F;nba&#x2F;_doc&#x2F;2?op_type&#x3D;create</span><br></pre></td></tr></table></figure></li><li>查询文档</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0x1-Elasticsearch概念&quot;&gt;&lt;a href=&quot;#0x1-Elasticsearch概念&quot; class=&quot;headerlink&quot; title=&quot;0x1 Elasticsearch概念&quot;&gt;&lt;/a&gt;0x1 Elasticsearch概念&lt;/h2&gt;</summary>
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    
    <category term="Elasticsearch" scheme="http://example.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发者常犯的10大翻译错误（译）</title>
    <link href="http://example.com/2021/03/08/JAVA%E5%BC%80%E5%8F%91%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%8410%E5%A4%A7%E9%94%99%E8%AF%AF%E8%AF%91/"/>
    <id>http://example.com/2021/03/08/JAVA%E5%BC%80%E5%8F%91%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%8410%E5%A4%A7%E9%94%99%E8%AF%AF%E8%AF%91/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://img.hacpai.com/bing/20190110.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"></p><h3 id="1-将-Array-转换成-ArrayList"><a href="#1-将-Array-转换成-ArrayList" class="headerlink" title="1.将 Array 转换成 ArrayList"></a>1.将 Array 转换成 ArrayList</h3><p>通常我们将 Array 转成 ArrayList 都是使用下面的语法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(arr);  </span><br></pre></td></tr></table></figure><p>Arrays.asList()方法将返回 ArrayList，它是 Arrays 中的一个私有静态类而不是 java.util.ArrayList 类。 <code>java.util.Arrays.ArrayList</code>类具有 set ()、 get ()和 contains ()方法，但没有任何用于添加元素的方法，因此其大小是固定的。 要创建一个真正的 ArrayList，你应该这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList &#x3D; new ArrayList&lt;String&gt;(Arrays.asList(arr));</span><br></pre></td></tr></table></figure><span id="more"></span><hr><h3 id="2-检查数组是否包含值"><a href="#2-检查数组是否包含值" class="headerlink" title="2.检查数组是否包含值"></a>2.检查数组是否包含值</h3><p>常见错误做法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set &#x3D; new HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line">return set.contains(targetValue);</span><br></pre></td></tr></table></figure><p>上面这个代码可以达到我们的目的，但是不需要转换 将列表转换为集合需要额外的时间。 可以简化成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(arr).contains(targetValue);</span><br></pre></td></tr></table></figure><hr><h3 id="3-从循环列表中删除某个元素"><a href="#3-从循环列表中删除某个元素" class="headerlink" title="3.从循环列表中删除某个元素"></a>3.从循环列表中删除某个元素</h3><p>错误做法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));</span><br><span class="line">for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>输出结果：<br><code>[b, d]</code><br>这种方法有一个严重的问题。删除元素时，列表的大小会缩小，索引也会发生变化。因此，如果您希望通过使用索引来删除循环中的多个元素，那将无法正常工作。<br>您可能知道使用迭代器是在循环中删除元素的正确方法，而且您知道 Java 中的 foreach 循环工作起来像迭代器，但实际上并非如此。代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));</span><br><span class="line"> </span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">if (s.equals(&quot;a&quot;))</span><br><span class="line">list.remove(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将抛出 <a href="https://www.programcreek.com/2014/01/java-util-concurrentmodificationexception/">ConcurrentModificationException</a>。<br>使用迭代器进行删除能够避免这个问题，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));</span><br><span class="line">Iterator&lt;String&gt; iter &#x3D; list.iterator();</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">String s &#x3D; iter.next();</span><br><span class="line"> </span><br><span class="line">if (s.equals(&quot;a&quot;)) &#123;</span><br><span class="line">iter.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next-必须在-remove-之前调用。"><a href="#next-必须在-remove-之前调用。" class="headerlink" title=".next() 必须在 .remove()之前调用。"></a><code>.next()</code> 必须在 <code>.remove()</code>之前调用。</h2><h3 id="4-Hashtable-vs-HashMap"><a href="#4-Hashtable-vs-HashMap" class="headerlink" title="4.Hashtable vs HashMap"></a>4.Hashtable vs HashMap</h3><p>map预览<br><img src="https://img.hacpai.com/file/2019/12/MapClassHierarchy600x354-34b5fd5e.jpg" alt="MapClassHierarchy600x354.jpg"></p><ul><li>HashMap：底层由哈希表实现，对键或值没有排序。</li><li>TreeMap：基于红黑树实现，并按键排序。</li><li>Hashtable：与 HashMap 相反，Hashtable 是同步的。 它有一个同步的开销。</li><li>LinkedHashMap：保留插入顺序，有序。</li></ul><p>注意项：<br><strong>如果 HashMap 的键是一个自定义对象，那么需要遵循 equals ()和 hashCode ()契约。</strong><br><strong>由于 TreeMaps 是按键排序的，因此 key 的对象必须能够相互比较，这就是它必须实现 Comparable 接口的原因</strong></p><h3 id="5-使用原始类型-Object-的集合"><a href="#5-使用原始类型-Object-的集合" class="headerlink" title="5.使用原始类型(Object)的集合"></a>5.使用原始类型(Object)的集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void add(List list, Object o)&#123;</span><br><span class="line">list.add(o);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">add(list, 10);</span><br><span class="line">String s &#x3D; list.get(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段会出现如下报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">at ...</span><br></pre></td></tr></table></figure><h2 id="使用原始类型集合是危险的，因为原始类型集合跳过了泛型类型检查，并且不安全。"><a href="#使用原始类型集合是危险的，因为原始类型集合跳过了泛型类型检查，并且不安全。" class="headerlink" title="使用原始类型集合是危险的，因为原始类型集合跳过了泛型类型检查，并且不安全。"></a>使用原始类型集合是危险的，因为原始类型集合跳过了泛型类型检查，并且不安全。</h2><p>###6. 访问级别<br>开发人员经常使用 public 作为类字段。 通过直接引用字段值很方便，但这是一个非常糟糕的设计。 正确的做法是尽可能低为成员提供低的访问级别。<br>下表总结了成员的不同修饰符的访问级别，访问级别决定字段和方法的可访问性。 它有4个级别: public、 protected、 package-private (没有显式修饰符)或 private。<br><img src="https://img.hacpai.com/file/2019/12/accesslevel-17093c67.png" alt="accesslevel.png"></p><h3 id="7-ArrayList-vs-LinkedList"><a href="#7-ArrayList-vs-LinkedList" class="headerlink" title="7.ArrayList vs. LinkedList"></a>7.ArrayList vs. LinkedList</h3><p>当开发人员不知道 ArrayList 和 LinkedList 之间的区别时，他们通常使用 ArrayList，因为它看起来很熟悉。 然而，它们之间存在着巨大的性能差异。<br>集合预览图如下。<br><img src="https://img.hacpai.com/file/2019/12/javacollectionhierarchy-e17306c4.jpeg" alt="javacollectionhierarchy.jpeg"><br>Arraylist 由一个可调整大小的数组实现。 随着更多的元素被添加到 ArrayList 中，它的大小会动态增加。 它的元素可以通过 get 和 set 方法直接访问，因为 ArrayList 实际上是一个数组。<br>Linkedlist 实现为双链表。 它在添加和删除方面的性能优于数组列表，但在 get 和 set 方法上性能较差。<br>时间复杂度比较如下：<br><img src="https://img.hacpai.com/file/2019/12/arraylistvslinkedlistcomplexity-2546b6b8.png" alt="arraylistvslinkedlistcomplexity.png"><br>性能比较：<br><img src="https://img.hacpai.com/file/2019/12/arraylistvslinkedlist1-6838cb4d.png" alt="arraylistvslinkedlist1.png"><br>他们的表现有明显的差异。 Linkedlist 在添加和删除方面更快，但在 get 方面更慢。 根据复杂度表和测试结果，我们可以确定何时使用 ArrayList 或 LinkedList。 简而言之，如果下列情况下 LinkedList 应该是首选的：</p><ul><li>元素没有大量的随机存取</li><li>有大量的添加 / 删除操作</li></ul><hr><h3 id="8-可变对象VS不可变对对象"><a href="#8-可变对象VS不可变对对象" class="headerlink" title="8.可变对象VS不可变对对象"></a>8.可变对象VS不可变对对象</h3><p>不可变对象有许多优点，如简单性、安全性等。 但是，对于每个不同的值，它需要一个单独的对象，而且对象太多可能会导致垃圾收集的高成本。 在可变和不可变之间进行选择时，应该有一个平衡。<br>通常，使用可变对象是为了避免产生过多的中间对象。 一个典型的例子是连接大量的字符串。 如果使用不可变字符串，则会生成许多可立即进行垃圾收集的对象。 这会浪费 CPU 的时间和精力，而使用可变对象是正确的解决方案（<code>StringBuilder</code>）</p><hr><h3 id="9-父类和子类构造器"><a href="#9-父类和子类构造器" class="headerlink" title="9.父类和子类构造器"></a>9.父类和子类构造器</h3><p><img src="https://img.hacpai.com/file/2019/12/Implicitsuperconstructorisundefinedfordefaultconstructor-7abcade6.png" alt="Implicitsuperconstructorisundefinedfordefaultconstructor.png"><br>由于未定义默认父类构造函数，因此发生此编译错误。 在 Java 中，如果类没有定义构造函数，编译器将默认为类插入默认的无参数构造函数。 如果在 Super 类中定义了一个构造函数，在这种情况下，Super (String s) ，编译器不会插入默认的无参数构造函数。 这就是上面提到的父类的情况。</p><hr><h3 id="10-使用””还是构造器初始化String"><a href="#10-使用””还是构造器初始化String" class="headerlink" title="10.使用””还是构造器初始化String"></a>10.使用””还是构造器初始化String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 使用双引号</span><br><span class="line">String x &#x3D; &quot;abc&quot;;</span><br><span class="line">&#x2F;&#x2F;2. 构造器方式</span><br><span class="line">String y &#x3D; new String(&quot;abc&quot;);</span><br></pre></td></tr></table></figure><p>下面我们分析一下他们之间的区别：</p><p><strong>例子1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a &#x3D; &quot;abcd&quot;;</span><br><span class="line">String b &#x3D; &quot;abcd&quot;;</span><br><span class="line">System.out.println(a &#x3D;&#x3D; b);  &#x2F;&#x2F; True</span><br><span class="line">System.out.println(a.equals(b)); &#x2F;&#x2F; True</span><br></pre></td></tr></table></figure><p>a==b为 true，因为 a 和 b 在方法区域中引用了相同的字符串。 内存引用是相同的。<br>当多次创建同一字符串时，每个不同字符串值只存储一个副本。 这叫做“字符串主流”。 Java 中的所有编译时常量字符串都会自动实现。</p><p><strong>例子2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String c &#x3D; new String(&quot;abcd&quot;);</span><br><span class="line">String d &#x3D; new String(&quot;abcd&quot;);</span><br><span class="line">System.out.println(c &#x3D;&#x3D; d);  &#x2F;&#x2F; False</span><br><span class="line">System.out.println(c.equals(d)); &#x2F;&#x2F; True</span><br></pre></td></tr></table></figure><p>c == d是 false，因为 c 和 d 引用堆中的两个不同对象。 不同的对象总是有不同的内存引用。</p><p>下面这个图表说明了上述两种情况：<br><img src="https://img.hacpai.com/file/2019/12/constructorvsdoublequotesJavaStringNewPage650x324-2d02ea02.png" alt="constructorvsdoublequotesJavaStringNewPage650x324.png"><br><img src="https://img.hacpai.com/file/2019/12/772dedd20f0443648fe19bf102c78efa-7ad8c0d8.jpeg" alt="772dedd20f0443648fe19bf102c78efa.jpeg"></p><p><a href="https://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/">原文链接</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20190110.jpg?imageView2/1/w/960/h/540/interlace/1/q/100&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-将-Array-转换成-ArrayList&quot;&gt;&lt;a href=&quot;#1-将-Array-转换成-ArrayList&quot; class=&quot;headerlink&quot; title=&quot;1.将 Array 转换成 ArrayList&quot;&gt;&lt;/a&gt;1.将 Array 转换成 ArrayList&lt;/h3&gt;&lt;p&gt;通常我们将 Array 转成 ArrayList 都是使用下面的语法，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; list &amp;#x3D; Arrays.asList(arr);  &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Arrays.asList()方法将返回 ArrayList，它是 Arrays 中的一个私有静态类而不是 java.util.ArrayList 类。 &lt;code&gt;java.util.Arrays.ArrayList&lt;/code&gt;类具有 set ()、 get ()和 contains ()方法，但没有任何用于添加元素的方法，因此其大小是固定的。 要创建一个真正的 ArrayList，你应该这样做:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ArrayList&amp;lt;String&amp;gt; arrayList &amp;#x3D; new ArrayList&amp;lt;String&amp;gt;(Arrays.asList(arr));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JDK10新特性</title>
    <link href="http://example.com/2021/03/08/JDK10%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/03/08/JDK10%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://img.hacpai.com/bing/20190220.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"></p><h3 id="1、局部变量类型推断var"><a href="#1、局部变量类型推断var" class="headerlink" title="1、局部变量类型推断var"></a>1、局部变量类型推断var</h3><p>JDK10 可以使⽤var作为局部变量类型推断标识符。 Local-Variable Type Inference（局部变量类型推断），顾名思义只能⽤做为局部变量 。</p><span id="more"></span><p><strong>注意：</strong></p><ul><li>仅适⽤于局部变量增强for循环的索引，传统for循环局部变量 </li><li>不能使⽤于⽅法形参、构造函数形参、⽅法返回类型或任何其他类型的变量声明 </li><li>标识符var不是关键字，⽽是⼀个保留类型名称，⽽且不⽀持类或接⼝叫var,也不符合命名规范</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package jdk10;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author by xw</span><br><span class="line"> * @Description JDK10新特性 之 var</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VarDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;根据推断为 字符串类型</span><br><span class="line">        var strVar &#x3D; &quot;springboot&quot;;</span><br><span class="line">        &#x2F;&#x2F; true</span><br><span class="line">        System.out.println(strVar instanceof String); </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;根据10L 推断long 类型</span><br><span class="line">        var longVar &#x3D; 10L;</span><br><span class="line">        &#x2F;&#x2F;根据 true推断 boolean 类型</span><br><span class="line">        var flag &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;var flag &#x3D; Boolean.valueOf(&quot;true&quot;);</span><br><span class="line">        &#x2F;&#x2F;System.out.println(flag instanceof Boolean);</span><br><span class="line">        &#x2F;&#x2F; 推断 ArrayList&lt;String&gt;</span><br><span class="line">        var listVar &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        &#x2F;&#x2F; true</span><br><span class="line">        System.out.println(listVar instanceof ArrayList);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 推断 Stream&lt;String&gt;</span><br><span class="line">        var streamVar &#x3D; Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);</span><br><span class="line">        &#x2F;&#x2F;true </span><br><span class="line">        System.out.println(streamVar instanceof Stream);</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            System.out.println(&quot;这个是 flag 变量，值为true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、并行、完整的-G1-垃圾收集器"><a href="#2、并行、完整的-G1-垃圾收集器" class="headerlink" title="2、并行、完整的 G1 垃圾收集器"></a>2、并行、完整的 G1 垃圾收集器</h3><p>G1垃圾收集器的设计目的是避免，但是当并发收集无法以足够快的速度回收内存时，就会发生回退的完全 GC旧的 G1 FULL GC 实现使用单线程标记-扫描-压缩算法。 在JDK10中，FULL GC 被并行化。</p><h3 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h3><ul><li>将 JDK 的多个存储库合并成一个，简化开发。目前的代码库被分解成了多个库，容易出现源代码的管理问题。</li><li>应用程序数据共享，通过跨进程共享通用类的元数据，减少空间占用及启动时长。</li><li>线程本地握手，不执行全局 VM 安全点也能对线程执行回调，同时实现单线程停止回调。</li><li>JDK 提供了一组默认证书，开源 Java SE 的 CA程序，对开发人员更具吸引力。</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20190220.jpg?imageView2/1/w/960/h/540/interlace/1/q/100&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、局部变量类型推断var&quot;&gt;&lt;a href=&quot;#1、局部变量类型推断var&quot; class=&quot;headerlink&quot; title=&quot;1、局部变量类型推断var&quot;&gt;&lt;/a&gt;1、局部变量类型推断var&lt;/h3&gt;&lt;p&gt;JDK10 可以使⽤var作为局部变量类型推断标识符。 Local-Variable Type Inference（局部变量类型推断），顾名思义只能⽤做为局部变量 。&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://example.com/2021/03/08/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/03/08/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-06-13T14:40:46.545Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.hacpai.com/bing/20181005.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><span id="more"></span><ul><li><p>语法变化</p><ul><li>Lamada 表达式</li><li>Default 方法</li><li>重复注解</li><li>扩展注解支持</li></ul></li><li><p>集合</p><ul><li>新增 Stream 流</li><li>HashMap 性能提升</li></ul></li><li><p>安全方面</p><ul><li>客户端 TLS 1.2 默认启用；</li><li>Sha-224 消息摘要；</li><li>对高熵随机数生成的更好支持；</li><li>持 Kerberos 5 协议转换和受限代理。</li><li>…</li></ul></li><li><p>工具</p><ul><li>提供 jjs 命令来调用 Nashorn 引擎；</li><li>Jdeps 命令行工具用于分析类文件；</li><li>JMX 提供远程访问诊断命令。</li></ul></li><li><p>国际化</p><ul><li>Unicode 增强，包括对 Unicode 6.2.0 的支持；</li><li>新的日历和语言环境 API；</li><li>可安装自定义资源包。</li></ul></li><li><p>新增日期处理包</p></li><li><p>IO 和 NIO</p><ul><li>减小 &lt;JDK_HOME&gt;/jre/lib/charsets.jar 文件大小；</li><li>java.lang.String(byte[], *)和 java.lang.String.getBytes()性能提升。</li></ul></li><li><p>新增工具类</p><ul><li>并行数组排序；</li><li>Base64 编码解码；</li><li>无符号算术支持 。</li></ul></li><li><p>网络</p><ul><li>新增 java.net.URLPermission；</li><li>在 java. net 类中。 如果安装了安全管理器，则 HttpURLConnection 调用打开连接的请求需要权限。</li></ul></li><li><p>并发</p><ul><li>添加新的类和接口</li></ul></li></ul><h2 id="JDK8-之-default-关键字"><a href="#JDK8-之-default-关键字" class="headerlink" title="JDK8 之 default 关键字"></a>JDK8 之 default 关键字</h2><p>在 jdk1.8 以前接口里面是只能有抽象 ⽅法，不能有任何 ⽅法的实现。jdk1.8⾥ ⾯打破了这个规定，引入了新的关键字 default，使用 default 修饰方法，可以在接口里面定义具体的方法实现。</p><ul><li>默认方法：接口里面定义一个默认方法，这个接口的实现类实现了这个接口之后，不用管这个 default 修饰的方法就可以直接调调用，即接口方法的默认实现</li><li>静态方法: 接口名.静态方法来访问接口中的静态方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface StudentService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * JAVA8中新增default关键字</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default void test()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static void test1() &#123;</span><br><span class="line">        System.out.println(&quot;这是静态⽅法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JDK8-之-base64-加解密-API"><a href="#JDK8-之-base64-加解密-API" class="headerlink" title="JDK8 之 base64 加解密 API"></a>JDK8 之 base64 加解密 API</h2><p>Jdk1.8 的 java.util 包中，新增了 Base64 的类。相比于传统 sun.misc 和 Apache Commons Codec 效率较高，不用导包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Base64Demo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * java 8新增 base64编码解码</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws UnsupportedEncodingException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) throws UnsupportedEncodingException &#123;</span><br><span class="line">        Base64.Encoder encoder &#x3D; Base64.getEncoder();</span><br><span class="line">        Base64.Decoder decoder &#x3D; Base64.getDecoder();</span><br><span class="line"></span><br><span class="line">        byte[] src &#x3D; &quot;hello world&quot;.getBytes();</span><br><span class="line">        String encodeData &#x3D; encoder.encodeToString(src);</span><br><span class="line">        System.out.println(&quot;编码数据：&quot;+encodeData);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;解码数据:&quot;+ new String(decoder.decode(encodeData),&quot;UTF-8&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8-之时间日期处理类"><a href="#JDK8-之时间日期处理类" class="headerlink" title="JDK8 之时间日期处理类"></a>JDK8 之时间日期处理类</h2><p>JAVA8 新增 LocalDate、LocalTime、LocalDateTime 日期处理类，LocalDate 只精确到天、LocalTime 只包含具体时间（时分秒）、LocalDateTime 包含日期和时间。新增 DateTimeFormatter(线程安全)和 Duration 对时间的处理变得极为方便，具体使用如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class LocalDateDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * LocalDate不包含具体时间（小时、分、秒），只有日期</span><br><span class="line">         *&#x2F;</span><br><span class="line">        LocalDate localDate &#x3D; LocalDate.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;当前时间:&quot;+ localDate);</span><br><span class="line">        System.out.println(&quot;当前月份&quot;+localDate.getMonthValue());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;增加</span><br><span class="line">        LocalDate newLocalDate &#x3D; localDate.plusYears(2);</span><br><span class="line">        System.out.println(&quot;增加的时间&quot;+newLocalDate);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;减小</span><br><span class="line">        LocalDate minLocalDate &#x3D; localDate.minusYears(66);</span><br><span class="line">        System.out.println(&quot;减小的时间&quot;+minLocalDate);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改月份</span><br><span class="line">        LocalDate localDate1 &#x3D;localDate.withMonth(5);</span><br><span class="line">        System.out.println(localDate1);</span><br><span class="line"></span><br><span class="line">        LocalDateTime localDateTime &#x3D; LocalDateTime.now();</span><br><span class="line">        Thread.sleep(1111);</span><br><span class="line">        System.out.println(localDateTime.isAfter(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;DateTimeFormatter线程安全</span><br><span class="line">        LocalDateTime ldt &#x3D; LocalDateTime.now();</span><br><span class="line">        System.out.println(ldt);</span><br><span class="line">        DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String ldtStr &#x3D; dtf.format(ldt);</span><br><span class="line">        System.out.println(ldtStr);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;时间比较</span><br><span class="line">        LocalDateTime today &#x3D; LocalDateTime.now();</span><br><span class="line">        System.out.println(today);</span><br><span class="line">        LocalDateTime changeDate &#x3D; LocalDateTime.of(2020,10,1,10,40,30);</span><br><span class="line">        System.out.println(changeDate);</span><br><span class="line">        Duration duration &#x3D; Duration.between( today,changeDate);&#x2F;&#x2F;第⼆个参数减第⼀个参数</span><br><span class="line"></span><br><span class="line">        System.out.println(duration.toDays());&#x2F;&#x2F;两个时间差的天数</span><br><span class="line">        System.out.println(duration.toHours());&#x2F;&#x2F;两个时间差的⼩时数</span><br><span class="line">        System.out.println(duration.toMinutes());&#x2F;&#x2F;两个时间差的分钟数</span><br><span class="line">        System.out.println(duration.toMillis());&#x2F;&#x2F;两个时间差的毫秒数</span><br><span class="line">        System.out.println(duration.toNanos());&#x2F;&#x2F;两个时间差的纳秒数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8-之-Lambda-表达式"><a href="#JDK8-之-Lambda-表达式" class="headerlink" title="JDK8 之 Lambda 表达式"></a>JDK8 之 Lambda 表达式</h2><p>在 JDK8 之前，Java 是不志持函数式编程的，所谓的函数编程，即可理解是将一个函数（也称为“行为”）作为 ⼀个参数进 行传递， ⾯向对象编程是对数据的抽象，⽽函数式编程则是对 行为的抽象（将行为作为 ⼀个参数进行传递）。<br>lambda 表达式 使 ⽤场景(前提)：⼀个接 ⼝中只包含 ⼀个方法，则可以使 ⽤ Lambda 表达式，这样的接口称之为“函数接口” 语法： (params) -&gt; expression。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class LamadaDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * JDK8之前创建线程</span><br><span class="line">         *&#x2F;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;hello world&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;JDK8</span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;hello world&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;JDK8之前排序</span><br><span class="line">        List&lt;String&gt; list &#x3D; Arrays.asList(&quot;aaa&quot;,&quot;ggg&quot;,&quot;ffff&quot;,&quot;ccc&quot;);</span><br><span class="line">        Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public int compare(String a, String b) &#123;</span><br><span class="line">                        return b.compareTo(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        for (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;JDK8排序</span><br><span class="line">        Collections.sort(list, (a,b)-&gt;b.compareTo(a)</span><br><span class="line">        );</span><br><span class="line">        for (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义函数编程</strong><br>定义一个函数式接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明这是一个函数式接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyLamada&lt;R,T&gt; &#123;</span><br><span class="line">    R operator(T t1,T t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyLamadaTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.out.println(operator(20, 5, (Integer x, Integer y) -&gt; &#123;</span><br><span class="line">            return x * y;</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(operator(20, 5, (x, y) -&gt; x + y));</span><br><span class="line">        System.out.println(operator(20, 5, (x, y) -&gt; x - y));</span><br><span class="line">        System.out.println(operator(20, 5, (x, y) -&gt; x &#x2F; y));</span><br><span class="line">    &#125;</span><br><span class="line">    public static Integer operator(Integer x, Integer y,</span><br><span class="line">                                   MyLamada&lt;Integer, Integer&gt; of) &#123;</span><br><span class="line">        return of.operator(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8-函数式编程"><a href="#JDK8-函数式编程" class="headerlink" title="JDK8 函数式编程"></a>JDK8 函数式编程</h2><p>Lambda 表达式必须先定义接 ⼝，创建相关 ⽅法之后才可使 ⽤，这样做 ⼗分不便，其实 java8 已经内置了许多接 ⼝, 例如下 ⾯四个功能型接 ⼝，所以 ⼀般很少会由 ⽤户去定义新的函数式接 ⼝。Java8 内置的四 ⼤核 ⼼函数式接 ⼝：</p><ol><li>Consumer<T> : 消费型接 ⼝：有 ⼊参，⽆返回值</li><li>Supplier<T> : 供给型接 ⼝：⽆ ⼊参，有返回值</li><li>Function&lt;T, R&gt; : 函数型接 ⼝：有 ⼊参，有返回值</li><li>Predicate<T> : 断 ⾔型接 ⼝：有 ⼊参，有返回值，返回值类型确定是 boolean</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public class FunctionDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;声明function函数</span><br><span class="line">        Function&lt;Integer,Integer&gt; function &#x3D; p-&gt;p*10;</span><br><span class="line">        System.out.println(function.apply(99));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;自定义function函数，只能穿一个参数</span><br><span class="line">        MyFunction&lt;String,String&gt; myFunction &#x3D; new MyFunction&lt;&gt;();</span><br><span class="line">        System.out.println(myFunction.apply(&quot;xw study&quot;));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;BiFunction支持传两个参数</span><br><span class="line">        BiFunction&lt;String,String,String&gt; biFunction &#x3D; (a,b)-&gt;a+b;</span><br><span class="line">        System.out.println(biFunction.apply(&quot;a&quot;,&quot;b&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author by xw</span><br><span class="line"> * @Description predicate有入参，有返回值，返回类型是boolean类型</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PredicateDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D;</span><br><span class="line">                Arrays.asList(&quot;awewrwe&quot;,&quot;vdssdsd&quot;,&quot;aoooo&quot;,&quot;psdddsd&quot;);</span><br><span class="line">        List&lt;String&gt; results &#x3D; filter(list,obj-&gt;obj.startsWith(&quot;a&quot;));</span><br><span class="line">        System.out.println(results);</span><br><span class="line">    &#125;</span><br><span class="line">    public static List&lt;String&gt; filter(List&lt;String&gt; list,</span><br><span class="line">                                      Predicate&lt;String&gt; predicate) &#123;</span><br><span class="line">        List&lt;String&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (String str : list) &#123;</span><br><span class="line">            if (predicate.test(str)) &#123;</span><br><span class="line">                results.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author by xw</span><br><span class="line"> * @Description supplier只有返回值，没有入参</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SupplierDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;Student student &#x3D; new Student();</span><br><span class="line">        Student student &#x3D; newStudent();</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    public static Student newStudent()&#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier &#x3D; ()-&gt; &#123;</span><br><span class="line">            Student student &#x3D; new Student();</span><br><span class="line">            student.setName(&quot;默认名称&quot;);</span><br><span class="line">            return student;</span><br><span class="line">        &#125;;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Student&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConsumerDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer &#x3D; obj-&gt;&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">            System.out.println(&quot;调⽤短信接⼝发送短信，或者打印⽇志&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        sendMsg(&quot;8888888&quot;,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sendMsg(String phone, Consumer&lt;String&gt; consumer)&#123;</span><br><span class="line">        consumer.accept(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>未完待续。。。。。<br>项目地址：<a href="https://github.com/2457081614/jdk-study.git">项目地址</a></p><h2 id="JDK8-之-Stream-流"><a href="#JDK8-之-Stream-流" class="headerlink" title="JDK8 之 Stream 流"></a>JDK8 之 Stream 流</h2><p>Stream 中 ⽂称为 “流”，通过将集合转换为这么 ⼀种叫做 “流”的元素队列，通过声明性方式， 能够对集合中的每个元素进 行一系列并行或串行的流水线操作。<br><strong>操作过程</strong></p><ol><li>数据元素便是原始集合，如 List、Set、Map 等</li><li>⽣成流，可以是串行流 stream() 或者并行流 parallelStream()</li><li>中间操作，可以是 排序，聚合，过滤，转换等</li><li>终端操作，很多流操作本身就会返回一个流，所以多个操作可以直接连接起来，最后统一进行收集</li></ol><h3 id="函数详解"><a href="#函数详解" class="headerlink" title="函数详解"></a>函数详解</h3><h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h4><ul><li>作用：将流中的每 ⼀个元素 T 映射为 R（类似类型转换）</li><li>应用场景: 开发中 Do 转 Dto</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void mapTest()</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;User&gt; list &#x3D; Arrays.asList(new User(1,&quot;⼩东&quot;,&quot;123&quot;),new</span><br><span class="line">                        User(21,&quot;jack&quot;,&quot;rawer&quot;),</span><br><span class="line">                new User(155,&quot;tom&quot;,&quot;sadfsdfsdfsd&quot;),</span><br><span class="line">                new User(231,&quot;marry&quot;,&quot;234324&quot;),new User(100,&quot;2222&quot;,&quot;122223&quot;));</span><br><span class="line">        List&lt;UserDTO&gt; userDTOList &#x3D; list.stream().map(obj-&gt;&#123;</span><br><span class="line">            UserDTO userDTO &#x3D; new UserDTO(obj.getId(),obj.getName());</span><br><span class="line">            return userDTO;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        System.out.println(userDTOList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h4><ul><li>作用：⽤于通过设置的条件过滤出元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤长度大于5的</span><br><span class="line"> private void filterTest() &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D; Arrays.asList(&quot;springboot&quot;, &quot;springcloud&quot;,</span><br><span class="line">                &quot;redis&quot;, &quot;git&quot;, &quot;netty&quot;, &quot;java&quot;, &quot;html&quot;, &quot;docker&quot;);</span><br><span class="line">        List&lt;String&gt; resultList &#x3D; list.stream().filter(obj -&gt; obj.length() &gt;</span><br><span class="line">                5).collect(Collectors.toList());</span><br><span class="line">        System.out.println(resultList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted 函数"></a>sorted 函数</h4><p>作用：sorted() 对流进 ⾏排序, 其中的元素必须实现 Comparable 接 ⼝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void sortdTest() &#123;</span><br><span class="line">        &#x2F;&#x2F;自然排序</span><br><span class="line">        List&lt;String&gt; list &#x3D; Arrays.asList(&quot;springboot&quot;, &quot;springcloud&quot;,</span><br><span class="line">                &quot;redis&quot;, &quot;git&quot;, &quot;netty&quot;, &quot;java&quot;, &quot;html&quot;, &quot;docker&quot;);</span><br><span class="line">        List&lt;String&gt; resultList &#x3D;</span><br><span class="line">                list.stream().sorted().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;根据⻓度顺序进⾏排序</span><br><span class="line">        resultList &#x3D;</span><br><span class="line">                list.stream().sorted(Comparator.comparing(obj -&gt;</span><br><span class="line">                        obj.length())).collect(Collectors.toList());</span><br><span class="line">        &#x2F;&#x2F;逆序排序</span><br><span class="line">        resultList &#x3D;</span><br><span class="line">                list.stream().sorted(Comparator.comparing(obj -&gt;</span><br><span class="line">                        obj.length(), Comparator.reverseOrder())).collect(Collectors.toList()</span><br><span class="line">                );</span><br><span class="line">        &#x2F;&#x2F; 逆序排序，根据effective java规范一般来说在stream表达式中，引用优先于lamada表达式使用。</span><br><span class="line">        resultList &#x3D;</span><br><span class="line">                list.stream().sorted(Comparator.comparing(String::length).reversed()</span><br><span class="line">                ).collect(Collectors.toList());</span><br><span class="line">        System.out.println(resultList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="limit-函数"><a href="#limit-函数" class="headerlink" title="limit 函数"></a>limit 函数</h4><p>作用：截断流使其最多只包含指定数量的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void limitTest() &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D; Arrays.asList(&quot;springboot&quot;, &quot;springcloud&quot;,</span><br><span class="line">                &quot;redis&quot;, &quot;git&quot;, &quot;netty&quot;, &quot;java&quot;, &quot;html&quot;, &quot;docker&quot;);</span><br><span class="line">        &#x2F;&#x2F;limit截取</span><br><span class="line">        List&lt;String&gt; resultList &#x3D;</span><br><span class="line">                list.stream().sorted(Comparator.comparing(String::length).reversed()</span><br><span class="line">                ).limit(3).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; result  [springcloud, springboot, docker]</span><br><span class="line">        System.out.println(resultList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="allMatch-和-anyMatch"><a href="#allMatch-和-anyMatch" class="headerlink" title="allMatch 和 anyMatch"></a>allMatch 和 anyMatch</h4><p>allMatch 检查是否匹配所有元素，只有全部符合才返回 true。anyMatch 检查是否至少匹配一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static void anyMatchAndAllMatchTest()</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D; Arrays.asList(&quot;springboot&quot;, &quot;springcloud&quot;, &quot;redis&quot;,</span><br><span class="line">                &quot;git&quot;, &quot;netty&quot;, &quot;java&quot;, &quot;html&quot;, &quot;docker&quot;);</span><br><span class="line">        boolean flag &#x3D; list.stream().allMatch(obj-&gt;obj.length()&gt;1);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">        flag &#x3D; list.stream().anyMatch(obj-&gt;obj.length()&gt;18);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="min-和-max-函数"><a href="#min-和-max-函数" class="headerlink" title="min 和 max 函数"></a>min 和 max 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static void minAndMaxTest() &#123;</span><br><span class="line">        List&lt;Student&gt; list &#x3D; Arrays.asList(new Student(32), new</span><br><span class="line">                Student(33), new Student(21), new Student(29), new Student(18));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;求最大值</span><br><span class="line">        Optional&lt;Student&gt; optional &#x3D; list.stream().max(Comparator.comparingInt(Student::getAge));</span><br><span class="line">        System.out.println(optional.get().getAge());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;求最小值</span><br><span class="line">        optional &#x3D; list.stream().min(Comparator.comparingInt(Student::getAge));</span><br><span class="line">        System.out.println(optional.get().getAge());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8-之-Optional-类"><a href="#JDK8-之-Optional-类" class="headerlink" title="JDK8 之 Optional 类"></a>JDK8 之 Optional 类</h2><ul><li>作用<ul><li>解决空指针异常</li></ul></li><li>创建<ul><li>of()方法，null 值作为参数传递进去,则会抛异常<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional opt &#x3D; Optional.of(user);</span><br></pre></td></tr></table></figure></li><li>ofNullable() ，如果对象即可能是 null 也可能是 ⾮ null，应该使 ⽤ ofNullable() ⽅法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional opt &#x3D; Optional.ofNullable(user);</span><br></pre></td></tr></table></figure></li><li>orElse()如果有值则返回该值，否则返回传递给它的参数值</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package jdk8.optional;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        User user &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果user是null的话，下面这句话会报错。</span><br><span class="line">        &#x2F;&#x2F;Optional&lt;User&gt; opt &#x3D; Optional.of(user);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;  orElse()如果有值则返回该值，否则返回传递给它的参数值</span><br><span class="line">        User user1 &#x3D; new User(&quot;1&quot;);</span><br><span class="line">        User user2 &#x3D; new User(&quot;2&quot;);</span><br><span class="line">        &#x2F;*</span><br><span class="line">        如果值存在则isPresent()⽅法会返回true，调⽤get()⽅法会返回该对象⼀般使⽤get之前需要</span><br><span class="line">        先验证是否有值，不然还会报错*&#x2F;</span><br><span class="line">        Optional&lt;User&gt; opt &#x3D; Optional.ofNullable(user);</span><br><span class="line">        Optional&lt;User&gt; opt1 &#x3D; Optional.ofNullable(user1);</span><br><span class="line">        System.out.println(&quot;opt &quot; + opt.isPresent());          &#x2F;&#x2F;false</span><br><span class="line">        System.out.println(&quot;opt1 &quot; + opt1.isPresent());       &#x2F;&#x2F;true</span><br><span class="line">        System.out.println(Optional.ofNullable(user1).orElse(user2));  &#x2F;&#x2F;user1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a>reduce 函数</h4><p>作用：聚合函数，根据 ⼀定的规则将 Stream 中的元素进 ⾏计算后返回 ⼀个唯 ⼀的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int value &#x3D; Stream.of(1, 2, 3, 4, 5).reduce((item1, item2) -&gt; item1 + item2).get();</span><br></pre></td></tr></table></figure><h4 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach 函数"></a>foreach 函数</h4><p>作用：循环遍历集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List results &#x3D; Arrays.asList(new Student(32),new Student(33),new Student(21),new Student(29),new Student(18));</span><br><span class="line">results.forEach(obj-&gt;&#123; System.out.println(obj.toString()); &#125;);</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>不能修改包含外部的变量的值</li><li>不能 ⽤ break 或者 return 或者 continue 等关键词结束或者跳过循环</li></ul><h4 id="collector-收集器"><a href="#collector-收集器" class="headerlink" title="collector 收集器"></a>collector 收集器</h4><p>作用：⼀个终端操作, ⽤于对流中的数据进 ⾏归集操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static  void collectTest()</span><br><span class="line">   &#123;</span><br><span class="line">       List&lt;Integer&gt; a &#x3D;Arrays.asList(1,2,3);</span><br><span class="line">       List&lt;Integer&gt; b &#x3D; a.stream().collect(Collectors.toList());</span><br><span class="line">       Set&lt;Integer&gt; c &#x3D; a.stream().collect(Collectors.toSet());</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="joining-函数"><a href="#joining-函数" class="headerlink" title="joining 函数"></a>joining 函数</h4><p>作用：拼接函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 该⽅法可以将Stream得到⼀个字符串， joining函数接受三个参数，分别表示 元素之间的连</span><br><span class="line">    * 接符、前缀和后缀。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private static void joiningTest()</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;3种重载⽅法</span><br><span class="line">      &#x2F;* Collectors.joining()</span><br><span class="line">       Collectors.joining(&quot;param&quot;)</span><br><span class="line">       Collectors.joining(&quot;param1&quot;, &quot;param2&quot;, &quot;param3&quot;)*&#x2F;</span><br><span class="line"></span><br><span class="line">       String result &#x3D; Stream.of(&quot;springboot&quot;, &quot;mysql&quot;, &quot;html5&quot;,</span><br><span class="line">               &quot;css3&quot;).collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;));</span><br><span class="line">       System.out.println(result); &#x2F;&#x2F;[springboot,mysql,html5,css3]</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="partitioningBy-分组"><a href="#partitioningBy-分组" class="headerlink" title="partitioningBy 分组"></a>partitioningBy 分组</h4><p>Collectors.partitioningBy 分组，key 是 boolean 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void parttitionByTest()</span><br><span class="line">   &#123;</span><br><span class="line">       List&lt;String&gt; list &#x3D; Arrays.asList(&quot;java&quot;, &quot;springboot&quot;,</span><br><span class="line">               &quot;HTML5&quot;,&quot;nodejs&quot;,&quot;CSS3&quot;);</span><br><span class="line">       Map&lt;Boolean, List&lt;String&gt;&gt; result &#x3D;</span><br><span class="line">               list.stream().collect(partitioningBy(obj -&gt; obj.length() &gt; 4));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F;key是 false 和true</span><br><span class="line">       &#x2F;&#x2F;result </span><br><span class="line">      &#x2F;&#x2F;&#123;false&#x3D;[java, CSS3], true&#x3D;[springboot, HTML5, nodejs]&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="group-by-分组"><a href="#group-by-分组" class="headerlink" title="group by 分组"></a>group by 分组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static void groupbyingTest()</span><br><span class="line">   &#123;</span><br><span class="line">       List&lt;Student&gt; students &#x3D; Arrays.asList(new Student(&quot;⼴东&quot;, 23), new</span><br><span class="line">               Student(&quot;⼴东&quot;, 24), new Student(&quot;⼴东&quot;, 23),new Student(&quot;北京&quot;, 22), new</span><br><span class="line">               Student(&quot;北京&quot;, 20), new Student(&quot;北京&quot;, 20),new Student(&quot;海南&quot;, 25));</span><br><span class="line">       Map&lt;String, Long&gt; listMap &#x3D;</span><br><span class="line">               students.stream().collect(Collectors.groupingBy(Student::getProvince,</span><br><span class="line">                       Collectors.counting()));</span><br><span class="line">       listMap.forEach((key, value) -&gt; &#123;System.out.println(key+&quot;省⼈数有&quot;+value);&#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="summarizing-集合统计"><a href="#summarizing-集合统计" class="headerlink" title="summarizing 集合统计"></a>summarizing 集合统计</h4><p>summarizing 统计相关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static void summarizingTest() &#123;</span><br><span class="line">        List&lt;Student&gt; students &#x3D; Arrays.asList(new Student(&quot;⼴东&quot;, 23), new</span><br><span class="line">                Student(&quot;⼴东&quot;, 24), new Student(&quot;⼴东&quot;, 23), new Student(&quot;北京&quot;, 22), new</span><br><span class="line">                Student(&quot;北京&quot;, 20), new Student(&quot;北京&quot;, 20), new Student(&quot;海南&quot;, 25));</span><br><span class="line">        IntSummaryStatistics summaryStatistics &#x3D;</span><br><span class="line">                students.stream().collect(Collectors.summarizingInt(Student::getAge));</span><br><span class="line">        System.out.println(&quot;平均值：&quot; + summaryStatistics.getAverage());</span><br><span class="line">        System.out.println(&quot;⼈数：&quot; + summaryStatistics.getCount());</span><br><span class="line">        System.out.println(&quot;最⼤值：&quot; + summaryStatistics.getMax());</span><br><span class="line">        System.out.println(&quot;最⼩值：&quot; + summaryStatistics.getMin());</span><br><span class="line">        System.out.println(&quot;总和：&quot; + summaryStatistics.getSum());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8-之新的内存空间"><a href="#JDK8-之新的内存空间" class="headerlink" title="JDK8 之新的内存空间"></a>JDK8 之新的内存空间</h2><h3 id="元空间（Metaspace）"><a href="#元空间（Metaspace）" class="headerlink" title="元空间（Metaspace）"></a>元空间（Metaspace）</h3><p>在 JDK8 及版本，有个区域叫做“永久代(permanent generation)， 通过 在命令 ⾏设置参数-XX:MaxPermSize 来设定永久代最 ⼤可分配的内存空间。该块内存主要是被 JVM⽤来存放 class 和 mate 信息的，当 class 被加载 loader 的时候就会 被存储到该内存区中，如 ⽅法的编译信息及字节码、常量池和符号解析、类的层级信息，字段，名字等</p><p>在 JDK8 使用本地内存来存储类元数据信息，叫做元空间，另外将常量及静态变量移到堆中，元空间并不在虚拟机中，存储在本地内存里面，在默认的情况下 Metaspace 的大小只与本地内存有关。默认不设置元空间大小的话会自动扩张，设置带下命令<br>-XX: MaxPermSize</p><p>优点：</p><ul><li>原来的字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息难以确定，指定永久代的大小比较困难，太小导致出现永久代溢出，太大容易导致老年代溢出。</li><li>永久代 GC 效率低</li></ul><p>参考文档：</p><ul><li><a href="https://wiki.openjdk.java.net/display/jdk8u/Main">open jdk8 updates wiki</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20181005.jpg?imageView2/1/w/960/h/540/interlace/1/q/100&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JDK11新特性</title>
    <link href="http://example.com/2021/03/08/JDK11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/03/08/JDK11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、新增-HttpClient-客户端"><a href="#1、新增-HttpClient-客户端" class="headerlink" title="1、新增 HttpClient 客户端"></a>1、新增 HttpClient 客户端</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>这个功能在 JDK9 中引入并在 JDK10 中得到了更新，最终在 JDK11 中发布，支持 HTTP1.1<br>和 HTTP/2。</p><span id="more"></span><p><strong>常用工具类和接口：</strong></p><ul><li>HttpClient.Builder HttpClient 构建 ⼯具类</li><li>HttpRequest.Builder HttpRequest 构建 ⼯具类</li><li>HttpRequest.BodyPublisher 将 Java 对象转换为可发送的 HTTP request body 字节流, 如 form 表单提交</li><li>HttpResponse.BodyHandler 处理接收到的 Response Body</li></ul><p><strong>Get 请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package jdk11;</span><br><span class="line"></span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.net.http.HttpClient;</span><br><span class="line">import java.net.http.HttpRequest;</span><br><span class="line">import java.net.http.HttpResponse;</span><br><span class="line">import java.time.Duration;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author by xw</span><br><span class="line"> * @Description TODO</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HttpClientTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final URI uri &#x3D; URI.create(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;GET请求</span><br><span class="line">    private static void testGet() &#123;</span><br><span class="line">        &#x2F;&#x2F;var httpClient &#x3D; HttpClient.newHttpClient();</span><br><span class="line">        &#x2F;&#x2F;设置建⽴连接超时 connect timeout</span><br><span class="line">        var httpClient &#x3D;</span><br><span class="line">                HttpClient.newBuilder().connectTimeout(Duration.ofMillis(5000)).build();</span><br><span class="line">        &#x2F;&#x2F;设置读取数据超时 read timeout</span><br><span class="line">        var request &#x3D;</span><br><span class="line">                HttpRequest.newBuilder().timeout(Duration.ofMillis(3000))</span><br><span class="line">                        .header(&quot;key1&quot;, &quot;v1&quot;)</span><br><span class="line">                        .header(&quot;key2&quot;, &quot;v2&quot;)</span><br><span class="line">                        .uri(uri).build();</span><br><span class="line">        System.out.println(request);</span><br><span class="line">        try &#123;</span><br><span class="line">            var response &#x3D; httpClient.send(request,</span><br><span class="line">                    HttpResponse.BodyHandlers.ofString());</span><br><span class="line">            System.out.println(response.body());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>POST 请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void testPost() &#123;</span><br><span class="line">        var httpClient &#x3D; HttpClient.newHttpClient();</span><br><span class="line">        var request &#x3D; HttpRequest.newBuilder()</span><br><span class="line">                .uri(uri)</span><br><span class="line">                .header(&quot;Content-Type&quot;, &quot;application&#x2F;x-www-formurlencoded&quot;)</span><br><span class="line">                .POST(HttpRequest.BodyPublishers.ofString(&quot;account&#x3D;123456&amp;pwd&#x3D;1234567890&quot;))</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            var response &#x3D; httpClient.send(request,</span><br><span class="line">                    HttpResponse.BodyHandlers.ofString());</span><br><span class="line">            System.out.println(response.body());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>异步 Get 请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 异步请求</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private static void testAsynGet() &#123;</span><br><span class="line">      var httpClient &#x3D; HttpClient.newBuilder().build();</span><br><span class="line">      var request &#x3D;</span><br><span class="line">              HttpRequest.newBuilder().timeout(Duration.ofMillis(3000))</span><br><span class="line">                      .header(&quot;key1&quot;, &quot;v1&quot;)</span><br><span class="line">                      .header(&quot;key2&quot;, &quot;v2&quot;)</span><br><span class="line">                      .uri(uri).build();</span><br><span class="line">      try &#123;</span><br><span class="line">          CompletableFuture&lt;String&gt; result &#x3D; httpClient.sendAsync(request,</span><br><span class="line">                  HttpResponse.BodyHandlers.ofString())</span><br><span class="line">                  .thenApply(HttpResponse::body);</span><br><span class="line">          System.out.println(result.get());</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>HTTP2 请求</strong><br>Http2 百度百科：<a href="https://baike.baidu.com/item/HTTP%202.0/12520156?fr=aladdin"></a><br>HTTP2 协议的强制要求 https，如果 ⽬标 URI 是 HTTP 的，则 ⽆法使 ⽤ HTTP 2 协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static void testHttp2() &#123;</span><br><span class="line">    var httpClient &#x3D; HttpClient.newBuilder()</span><br><span class="line">            .connectTimeout(Duration.ofMillis(3000))</span><br><span class="line">            &#x2F;&#x2F;指定版本</span><br><span class="line">            .version(HttpClient.Version.HTTP_2)</span><br><span class="line">            .build();</span><br><span class="line">    var request &#x3D; HttpRequest.newBuilder()</span><br><span class="line">            .timeout(Duration.ofMillis(3000))</span><br><span class="line">            .header(&quot;key1&quot;, &quot;v1&quot;)</span><br><span class="line">            .header(&quot;key2&quot;, &quot;v2&quot;)</span><br><span class="line">            .uri(uri1)</span><br><span class="line">            .build();</span><br><span class="line">    try &#123;</span><br><span class="line">        var response &#x3D; httpClient.send(request,</span><br><span class="line">                HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());</span><br><span class="line">        System.out.println(response.version());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、javac-和-Java-命令优化"><a href="#2、javac-和-Java-命令优化" class="headerlink" title="2、javac 和 Java 命令优化"></a>2、javac 和 Java 命令优化</h3><p>我们在 jdk11 以前运行 Java 程序，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#编译</span><br><span class="line">javac xxx.java</span><br><span class="line">#运行</span><br><span class="line">java xxx</span><br></pre></td></tr></table></figure><p>jdk11 以后运行 Java 程序，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 本地不会产生class文件</span><br><span class="line">java xxx.java</span><br></pre></td></tr></table></figure><h3 id="3、ZGC-可伸缩的低延迟垃圾回收器-实验阶段"><a href="#3、ZGC-可伸缩的低延迟垃圾回收器-实验阶段" class="headerlink" title="3、ZGC(可伸缩的低延迟垃圾回收器)-实验阶段"></a>3、ZGC(可伸缩的低延迟垃圾回收器)-实验阶段</h3><p>ZGC，是一个可伸缩的低延迟垃圾收集器。 它旨在实现以下目标:</p><ul><li>暂停时间不要超过 10 毫秒</li><li>暂停时间不会随堆大小的增加而增加，能够在很大的堆内存中进行高效垃圾回收。</li></ul><p>Zgc 的核心是一个并发垃圾收集器，这意味着所有繁重的提升工作(标记、压缩、引用处理、字符串表清理等)都是在 Java 线程继续执行时完成的。 这大大限制了垃圾收集对应用程序响应时间的影响。</p><h3 id="4、Epsilon-GC"><a href="#4、Epsilon-GC" class="headerlink" title="4、Epsilon GC"></a>4、Epsilon GC</h3><p>Epsilon GC 是一种新的实验性无运行垃圾收集器。 Epsilon GC 只处理内存分配，不实现任何内存回收机制。 它对于性能测试非常有用，可以对比其他 gc 的成本及效率。 它可以用来在测试中方便地确定内存占用和内存压力。</p><h3 id="5、移除方法"><a href="#5、移除方法" class="headerlink" title="5、移除方法"></a>5、移除方法</h3><p>方法 Thread.destroy ()和 Thread.stop (Throwable)已被删除。</p><p><strong>参考文档：</strong><br><a href="https://www.oracle.com/technetwork/java/javase/11-relnote-issues-5012449.html#NewFeature">官网文档</a><br><a href="https://github.com/2457081614/jdk-study">项目代码地址</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1、新增-HttpClient-客户端&quot;&gt;&lt;a href=&quot;#1、新增-HttpClient-客户端&quot; class=&quot;headerlink&quot; title=&quot;1、新增 HttpClient 客户端&quot;&gt;&lt;/a&gt;1、新增 HttpClient 客户端&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;这个功能在 JDK9 中引入并在 JDK10 中得到了更新，最终在 JDK11 中发布，支持 HTTP1.1&lt;br&gt;和 HTTP/2。&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习笔记-垃圾回收算法</title>
    <link href="http://example.com/2021/03/08/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/03/08/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://img.hacpai.com/bing/20180228.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"></p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存</p><span id="more"></span><h2 id="对象存活算法"><a href="#对象存活算法" class="headerlink" title="对象存活算法"></a>对象存活算法</h2><p><strong>判断对象是否存活算法，讲解对象垃圾回收对象是否回收判断</strong></p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数方式最基本的形态就是让每个被管理的对象与一个引用计数器关联在一起，该计数器记录着该对象当前被引用的次数，每当创建一个新的引用指向该对象时其计数器就加1，每当指向该对象的引用失效时计数器就减1。当该计数器的值降到0就认为对象死亡。</p><h4 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h4><p>1、强引用。垃圾回收器不会回收强引用类型的对象。比如A a = new A();<br>2、软引用。内存不足的时候是可以被暂时回收的。当JVM中的内存不足的时候，垃圾回收器会释放那些只被软引用所指向的对象。如果全部释放完这些对象之后，内存还不足，才会抛出OutOfMemory错误。<br>3、弱引用。下一次垃圾回收时回收。<br>4、虚引用。任何时候都有可能被垃圾回收器被回收。</p><p><img src="https://img.hacpai.com/file/2019/11/image-ccbb2a69.png" alt="image.png"></p><h3 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h3><p>把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p><p>java中可作为GC Root的对象有</p><ul><li>虚拟机栈中引用的对象（本地变量表）   </li><li>本地方法栈中引用的对象  </li><li>方法区中静态属性引用的对象  </li><li>方法区中常量引用的对象</li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。见图解。<br><img src="https://img.hacpai.com/file/2019/11/image-a66aca4d.png" alt="image.png"><br>黑色块为需要回收的对象。</p><p>缺点：</p><ul><li>一个是效率问题，标记和清除两个过程的效率都不高；</li><li>另一个是空间问题，如图所示，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="https://img.hacpai.com/file/2019/11/image-a22c870c.png" alt="image.png"></p><p>为甚么出现复制算法？</p><ul><li>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按量划分为大小相等的两块，每次只使用其中的一块</li><li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li><li>新生代中的对象 98%是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。 Survivor from 和Survivor to ，内存比例 8：1：1</li><li>当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1, 也就是每次新生代中可用内存空间为整个新生代容量的 90% (80%+10%），只有 10% 的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10%的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li></ul><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>一般把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记一整理”算法来进行回收。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20180228.jpg?imageView2/1/w/960/h/540/interlace/1/q/100&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;意义&quot;&gt;&lt;a href=&quot;#意义&quot; class=&quot;headerlink&quot; title=&quot;意义&quot;&gt;&lt;/a&gt;意义&lt;/h2&gt;&lt;p&gt;Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="http://example.com/2021/03/08/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/03/08/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://img.hacpai.com/bing/20171224.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JVM运行时数据区包括方法区、堆、虚拟机栈、本地方法栈、程序计数器等，其中方法区和堆属于线程共享数据，虚拟机栈、本地方法栈、程序计数器为线程隔离数据。</p><span id="more"></span><p><img src="https://img.hacpai.com/file/2019/11/image-a4187753.png" alt="image.png"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。因此程序计数器是线程隔离的，它需要保证每个线程能够正确的执行命令。（从汇编角度来看功能像EIP寄存器）</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>  每个方法在执行的同时都会创建一个栈帧（Stack Framel）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）以及对象引用（reference 类型）。<strong>虚拟机栈的内存不需要垃圾回收器回收</strong>。</p><p>  如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。可以看下面demo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author xw</span><br><span class="line"> * @Description java虚拟机栈堆栈溢出测试</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StackOverFlowErrorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static  void test()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError  </span><br><span class="line"> at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691)  </span><br><span class="line"> at java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:579)  </span><br><span class="line"> at sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:271)</span><br></pre></td></tr></table></figure><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈类似，不过是作用于本地方法，即native方法。</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是Java内存区域中一块用来存放对象实例的区域，【几乎所有的对象实例都在这里分配内存】，也是 Java 虚拟机所管理的内存中最大的一块 Java 堆是被所有线程共享的一块内存区域，同时也是垃圾收集的主要区域。</p><ul><li>-Xmx 堆最大内存</li><li>-Xms 初始内存<br>一般建议最大内存和初始内存保持一样大小。</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。类信息包括类版本号、接口、方法。<br>这块区域的回收目标主要是针对常量池的回收和类型的卸载。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p><img src="https://img.hacpai.com/file/2019/11/15209668811969-5884104f.jpg" alt="15209668811969.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20171224.jpg?imageView2/1/w/960/h/540/interlace/1/q/100&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;JVM运行时数据区包括方法区、堆、虚拟机栈、本地方法栈、程序计数器等，其中方法区和堆属于线程共享数据，虚拟机栈、本地方法栈、程序计数器为线程隔离数据。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK9新特性</title>
    <link href="http://example.com/2021/03/08/JDK9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/03/08/JDK9%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><span id="more"></span><ul><li><p>模块系统</p><ul><li> 引入了一个新的可选阶段，即链接时间(link time) ，它位于编译时和运行时之间，在此期间可以将一组模块组装并优化为一个定制的运行时映像;</li><li></li></ul></li><li><p>版本控制<br>提供一种简化的版本字符串格式，有助于明确区分主版本、次版本、安全版本和修补程序更新版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$MAJOR.$MINOR.$SECURITY.$PATCH</span><br><span class="line"></span><br><span class="line">MAJOR 主版本号</span><br><span class="line">MINOR 小更新版本号</span><br><span class="line">SECURITY 针对安全更新的版本号</span><br><span class="line">PATCH 补丁版本号</span><br></pre></td></tr></table></figure></li><li><p>安装包新特性</p><ul><li>Windows版本提供在安装程序的欢迎页中启用或禁用 web 部署的选项。</li><li> macOs提供关于卸载当前 CPU 版本后下一个 CPU 可用性的通知,在更新 JRE 时增强用户体验。</li></ul></li><li><p>工具新特性</p><ul><li> jshell</li><li> 添加更多诊断命令</li><li> 删除启动时的 JRE 版本选择</li><li> 支持多版本JAR文件</li><li> 移除 hprof agent</li><li> 移除jhat</li><li> jlink（作用:将一组模块及其依赖关系组装并优化为自定义的运行时映像）</li></ul></li><li><p>安全方面</p><ul><li> 数据传输层加密</li><li> TLS 应用层协议协商扩展</li><li> 支持 SHA-3加密散列函数</li><li> 将默认密钥存储类型从 JKS 转换为 PKCS12。</li><li> 禁止SHA-1证书</li><li> GHASH and RSA性能提升</li></ul></li><li><p>Javadoc 新功能</p><ul><li>简化 Doclet API</li><li>支持HTML5</li><li> javaDoc查询</li><li> 支持模块</li></ul></li><li><p>JVM新特性</p><ul><li> 分段代码缓存（将代码缓存划分为不同的段，每个段包含特定类型的已编译代码，以提高性能并启用未来的扩展）</li><li>删除不推荐的GC组合</li><li>G1作为默认垃圾回收器</li><li>不推荐使用CMS </li></ul></li></ul><h3 id="1、Jshell"><a href="#1、Jshell" class="headerlink" title="1、Jshell"></a>1、Jshell</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>JShell 是 Java 9 新增的一个交互式的编程环境工具。它允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接 输入表达式并查看其执行结果。</p><h4 id="使用-Jshell"><a href="#使用-Jshell" class="headerlink" title="使用 Jshell"></a>使用 Jshell</h4><p>常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; &#x2F;help</span><br><span class="line">|  键入 Java 语言表达式, 语句或声明。</span><br><span class="line">|  或者键入以下命令之一:</span><br><span class="line">|  &#x2F;list [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出您键入的源</span><br><span class="line">|  &#x2F;edit &lt;名称或 id&gt;</span><br><span class="line">|       编辑按名称或 id 引用的源条目</span><br><span class="line">|  &#x2F;drop &lt;名称或 id&gt;</span><br><span class="line">|       删除按名称或 id 引用的源条目</span><br><span class="line">|  &#x2F;save [-all|-history|-start] &lt;文件&gt;</span><br><span class="line">|       将片段源保存到文件。</span><br><span class="line">|  &#x2F;open &lt;file&gt;</span><br><span class="line">|       打开文件作为源输入</span><br><span class="line">|  &#x2F;vars [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出已声明变量及其值</span><br><span class="line">|  &#x2F;methods [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出已声明方法及其签名</span><br><span class="line">|  &#x2F;types [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出已声明的类型</span><br><span class="line">|  &#x2F;imports</span><br><span class="line">|       列出导入的项</span><br><span class="line">|  &#x2F;exit</span><br><span class="line">|       退出 jshell</span><br><span class="line">|  &#x2F;env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] ...</span><br><span class="line">|       查看或更改评估上下文</span><br><span class="line">|  &#x2F;reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]...</span><br><span class="line">|       重启 jshell</span><br><span class="line">|  &#x2F;reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]...</span><br><span class="line">|       重置和重放相关历史记录 -- 当前历史记录或上一个历史记录 (-restore)</span><br><span class="line">|  &#x2F;history</span><br><span class="line">|       您键入的内容的历史记录</span><br><span class="line">|  &#x2F;help [&lt;command&gt;|&lt;subject&gt;]</span><br><span class="line">|       获取 jshell 的相关信息</span><br><span class="line">|  &#x2F;set editor|start|feedback|mode|prompt|truncation|format ...</span><br><span class="line">|       设置 jshell 配置信息</span><br><span class="line">|  &#x2F;? [&lt;command&gt;|&lt;subject&gt;]</span><br><span class="line">|       获取 jshell 的相关信息</span><br><span class="line">|  &#x2F;!</span><br><span class="line">|       重新运行上一个片段</span><br><span class="line">|  &#x2F;&lt;id&gt;</span><br><span class="line">|       按 id 重新运行片段</span><br><span class="line">|  &#x2F;-&lt;n&gt;</span><br><span class="line">|       重新运行前面的第 n 个片段</span><br><span class="line">|</span><br><span class="line">|  有关详细信息, 请键入 &#39;&#x2F;help&#39;, 后跟</span><br><span class="line">|  命令或主题的名称。</span><br><span class="line">|  例如 &#39;&#x2F;help &#x2F;list&#39; 或 &#39;&#x2F;help intro&#39;。主题:</span><br><span class="line">|</span><br><span class="line">|  intro</span><br><span class="line">|       jshell 工具的简介</span><br><span class="line">|  shortcuts</span><br><span class="line">|       片段和命令输入提示, 信息访问以及</span><br><span class="line">|       自动代码生成的按键说明</span><br><span class="line">|  context</span><br><span class="line">|       &#x2F;env &#x2F;reload 和 &#x2F;reset 的评估上下文选项</span><br><span class="line"></span><br><span class="line">jshell&gt; &#x2F;help</span><br><span class="line">|  键入 Java 语言表达式, 语句或声明。</span><br><span class="line">|  或者键入以下命令之一:</span><br><span class="line">|  &#x2F;list [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出您键入的源</span><br><span class="line">|  &#x2F;edit &lt;名称或 id&gt;</span><br><span class="line">|       编辑按名称或 id 引用的源条目</span><br><span class="line">|  &#x2F;drop &lt;名称或 id&gt;</span><br><span class="line">|       删除按名称或 id 引用的源条目</span><br><span class="line">|  &#x2F;save [-all|-history|-start] &lt;文件&gt;</span><br><span class="line">|       将片段源保存到文件。</span><br><span class="line">|  &#x2F;open &lt;file&gt;</span><br><span class="line">|       打开文件作为源输入</span><br><span class="line">|  &#x2F;vars [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出已声明变量及其值</span><br><span class="line">|  &#x2F;methods [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出已声明方法及其签名</span><br><span class="line">|  &#x2F;types [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出已声明的类型</span><br><span class="line">|  &#x2F;imports</span><br><span class="line">|       列出导入的项</span><br><span class="line">|  &#x2F;exit</span><br><span class="line">|       退出 jshell</span><br><span class="line">|  &#x2F;env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] ...</span><br><span class="line">|       查看或更改评估上下文</span><br><span class="line">|  &#x2F;reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]...</span><br><span class="line">|       重启 jshell</span><br><span class="line">|  &#x2F;reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]...</span><br><span class="line">|       重置和重放相关历史记录 -- 当前历史记录或上一个历史记录 (-restore)</span><br><span class="line">|  &#x2F;history</span><br><span class="line">|       您键入的内容的历史记录</span><br><span class="line">|  &#x2F;help [&lt;command&gt;|&lt;subject&gt;]</span><br><span class="line">|       获取 jshell 的相关信息</span><br><span class="line">|  &#x2F;set editor|start|feedback|mode|prompt|truncation|format ...</span><br><span class="line">|       设置 jshell 配置信息</span><br><span class="line">|  &#x2F;? [&lt;command&gt;|&lt;subject&gt;]</span><br><span class="line">|       获取 jshell 的相关信息</span><br><span class="line">|  &#x2F;!</span><br><span class="line">|       重新运行上一个片段</span><br><span class="line">|  &#x2F;&lt;id&gt;</span><br><span class="line">|       按 id 重新运行片段</span><br><span class="line">|  &#x2F;-&lt;n&gt;</span><br><span class="line">|       重新运行前面的第 n 个片段</span><br><span class="line">|</span><br><span class="line">|  有关详细信息, 请键入 &#39;&#x2F;help&#39;, 后跟</span><br><span class="line">|  命令或主题的名称。</span><br><span class="line">|  例如 &#39;&#x2F;help &#x2F;list&#39; 或 &#39;&#x2F;help intro&#39;。主题:</span><br><span class="line">|</span><br><span class="line">|  intro</span><br><span class="line">|       jshell 工具的简介</span><br><span class="line">|  shortcuts</span><br><span class="line">|       片段和命令输入提示, 信息访问以及</span><br><span class="line">|       自动代码生成的按键说明</span><br><span class="line">|  context</span><br><span class="line">|       &#x2F;env &#x2F;reload 和 &#x2F;reset 的评估上下文选项</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jshell&gt; 1+2</span><br><span class="line">$1 &#x3D;&#x3D;&gt; 3</span><br><span class="line"></span><br><span class="line">##创建方法</span><br><span class="line">jshell&gt; int add(int a,int b)&#123;return a+b;&#125;</span><br><span class="line">|  已创建 方法 a(int,int)</span><br><span class="line"></span><br><span class="line">jshell&gt; int aaa(int a,int b)&#123;return a+b;&#125;</span><br><span class="line">|  已创建 方法 aaa(int,int)</span><br><span class="line"></span><br><span class="line">## 调用方法</span><br><span class="line">jshell&gt; a(1,2)</span><br><span class="line">$4 &#x3D;&#x3D;&gt; 3</span><br><span class="line"></span><br><span class="line">jshell&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、接口使用私有方法"><a href="#2、接口使用私有方法" class="headerlink" title="2、接口使用私有方法"></a>2、接口使用私有方法</h3><p>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package jdk9;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author by xw</span><br><span class="line"> * @Description JDK9接口私有方案测试</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface InterfacePrivateMethod &#123;</span><br><span class="line"></span><br><span class="line">    void hello();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * JDK8 允许接口有default方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default void test()</span><br><span class="line">    &#123;</span><br><span class="line">        privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * JDK9 允许接口私有的实现方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void privateMethod() &#123;</span><br><span class="line">        System.out.println(&quot;interface private method test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package jdk9;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author by xw</span><br><span class="line"> * @Description TODO</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class InterfacePrivateMethodImpl implements InterfacePrivateMethod&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InterfacePrivateMethod interfacePrivateMethod &#x3D; new InterfacePrivateMethodImpl();</span><br><span class="line">        interfacePrivateMethod.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：<br>正常运行，输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface private method test</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="3、增加-try-with-resources"><a href="#3、增加-try-with-resources" class="headerlink" title="3、增加 try-with-resources"></a>3、增加 try-with-resources</h3><p>在 JDK7 中，新增了 try-with-rsources 语句，可以在 try 的括号中初始化资源，可以实现资源自动关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * JDK7使用try-with-resources语句需要在try中初始化资源，</span><br><span class="line">    * 可以实现自动释放</span><br><span class="line">    *</span><br><span class="line">    * @param filepath 路径</span><br><span class="line">    * @throws FileNotFoundException</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private void jdk7TryWithResource(String filepath) throws FileNotFoundException &#123;</span><br><span class="line">       OutputStream out &#x3D; new FileOutputStream(filepath);</span><br><span class="line">       try(OutputStream temp &#x3D; out;)</span><br><span class="line">       &#123;</span><br><span class="line">           temp.write((filepath+&quot;可以学习java架构课程&quot;).getBytes()); &#125;</span><br><span class="line">       catch (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在JDK9中，改进了try-with-resources语句，在try外进⾏初始化，在括号内引⽤，即可实现 资源⾃动关闭，多个变量则⽤分号进⾏分割，不需要声明资源 out 就可以使⽤它，并得到相同的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * JDK9增强</span><br><span class="line">    *</span><br><span class="line">    *</span><br><span class="line">    * @param filepath</span><br><span class="line">    * @throws FileNotFoundException</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private static void test(String filepath) throws FileNotFoundException &#123;</span><br><span class="line">       OutputStream out &#x3D; new FileOutputStream(filepath);</span><br><span class="line">       try (out) &#123;</span><br><span class="line">           out.write((filepath + &quot;java9 try-with-resources test&quot;).getBytes());</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="4、新增集合API"><a href="#4、新增集合API" class="headerlink" title="4、新增集合API"></a>4、新增集合API</h4><p>JDK9新增快速创建只读集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package jdk9;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author by xw</span><br><span class="line"> * @Description 快速创建只读集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UnmodifiableListTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;1&quot;);</span><br><span class="line">        list.add(&quot;2&quot;);</span><br><span class="line">        list.add(&quot;3&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置为只读List集合</span><br><span class="line">        list &#x3D; Collections.unmodifiableList(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        set.add(&quot;1&quot;);</span><br><span class="line">        set.add(&quot;2&quot;);</span><br><span class="line">        set.add(&quot;3&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置为只读Set集合</span><br><span class="line">        set &#x3D; Collections.unmodifiableSet(set);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key1&quot;, &quot;1&quot;);</span><br><span class="line">        map.put(&quot;key2&quot;, &quot;2&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置为只读Map集合</span><br><span class="line">        map &#x3D; Collections.unmodifiableMap(map);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5、新增Strean-API"><a href="#5、新增Strean-API" class="headerlink" title="5、新增Strean API"></a>5、新增Strean API</h3><p>1、takeWhile与dropWhile</p><ul><li>在有序的集合中，takeWhile从 Stream 中获取⼀部分数据, 返回从头开始的尽可能多的元素, 直到遇到第⼀ 个false结果，如果第⼀个值不满⾜断⾔条件，将返回⼀个空的 Stream，dropWhile效果与其相反</li><li>在无序集合中，好像没什么实际的应用场景。。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package jdk9;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author by xw</span><br><span class="line"> * @Description TODO</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AddStreamApi &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 有序集合</span><br><span class="line">        List&lt;String&gt; takeWhilelist &#x3D;</span><br><span class="line">                List.of(&quot;springboot&quot;, &quot;java&quot;, &quot;html&quot;, &quot;&quot;, &quot;git&quot;).stream().takeWhile(obj -&gt; !obj.isEmpty()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;takewhile list &quot; + takeWhilelist);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 无序集合</span><br><span class="line">        Set&lt;String&gt; takewhileSet &#x3D; List.of(&quot;springboot&quot;, &quot;java&quot;, &quot;html&quot;, &quot;&quot;, &quot;git&quot;).stream().takeWhile(obj -&gt; !obj.isEmpty()).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(&quot;takewhile set&quot; + takewhileSet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; dropWhileList &#x3D; List.of(&quot;springboot&quot;, &quot;java&quot;, &quot;html&quot;, &quot;&quot;, &quot;git&quot;).stream().dropWhile(obj -&gt; !obj.isEmpty())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(&quot;dropwhile list&quot; + dropWhileList);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; dropWhileSet &#x3D; List.of(&quot;springboot&quot;, &quot;java&quot;, &quot;html&quot;, &quot;&quot;, &quot;git&quot;).stream().dropWhile(obj -&gt; !obj.isEmpty())</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        System.out.println(&quot;dropwhile set&quot; + dropWhileSet);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>运行结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">takewhile list [springboot, java, html]</span><br><span class="line">takewhile set[java, html, springboot]</span><br><span class="line">dropwhile list[, git]</span><br><span class="line">dropwhile set[, git]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="6、去掉jhat工具"><a href="#6、去掉jhat工具" class="headerlink" title="6、去掉jhat工具"></a>6、去掉jhat工具</h3><p>jhat也是jdk内置的工具之一。主要是用来分析java堆的命令，可以将堆中的对象以html的形式显示出来,JDK9中已经移除该功能。</p><h3 id="7、-垃圾回收器更改"><a href="#7、-垃圾回收器更改" class="headerlink" title="7、 垃圾回收器更改"></a>7、 垃圾回收器更改</h3><p>JDK9移除了下面回收器组合：</p><ul><li>DefNew + CMS  </li><li>ParNew + SerialOld   </li><li>Incremental CMS</li></ul><p>删除的命令行：</p><ul><li><code>-Xincgc</code></li><li><code>-XX:+CMSIncrementalMode</code></li><li><code>-XX:+UseCMSCompactAtFullCollection</code></li><li><code>-XX:+CMSFullGCsBeforeCompaction</code></li><li><code>-XX:+UseCMSCollectionPassing</code></li></ul><p><strong>G1作为默认垃圾回收器，同时不推荐CMS并发标记进行垃圾回收</strong></p><p>参考文档：<br><a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6">JDK9新特性官方文档</a><br><a href="https://github.com/2457081614/jdk-study">代码地址</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JVM堆内存分配</title>
    <link href="http://example.com/2021/03/08/JVM%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://example.com/2021/03/08/JVM%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.hacpai.com/bing/20191105.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"></p><ul><li>Java堆内存区域的划分以及作用讲解</li><li>对象分配的规则有哪些<ul><li>对象主要分配在新生代的 Eden 区上</li><li>如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配</li><li>少数情况下也可能会直接分配在老年代中</li></ul></li><li>GC参数指定垃圾回收<ul><li>-Xms20 M、-Xmx20 M、-Xmn1 0 M 这 3 个参数限制了 Java 堆大小为 20 MB，不可扩展，其中 10 MB 分配给新生代，剩下的 10 MB 分配给老年代。-Xx: SurvivorRatio= 8 决定了新生代中 Eden 区与两个 Survivor 区的空间比例是 8:1</li></ul></li><li>新生代与老年代<ul><li>新生代 GC (Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度老年代 GC (Major GC/ Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</li></ul></li></ul><span id="more"></span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xmx 堆内存最大</span><br><span class="line">-Xmn 年轻代内存大小</span><br><span class="line">-Xms 初始堆内存大小   </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20191105.jpg?imageView2/1/w/960/h/540/interlace/1/q/100&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java堆内存区域的划分以及作用讲解&lt;/li&gt;
&lt;li&gt;对象分配的规则有哪些&lt;ul&gt;
&lt;li&gt;对象主要分配在新生代的 Eden 区上&lt;/li&gt;
&lt;li&gt;如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配&lt;/li&gt;
&lt;li&gt;少数情况下也可能会直接分配在老年代中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GC参数指定垃圾回收&lt;ul&gt;
&lt;li&gt;-Xms20 M、-Xmx20 M、-Xmn1 0 M 这 3 个参数限制了 Java 堆大小为 20 MB，不可扩展，其中 10 MB 分配给新生代，剩下的 10 MB 分配给老年代。-Xx: SurvivorRatio= 8 决定了新生代中 Eden 区与两个 Survivor 区的空间比例是 8:1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新生代与老年代&lt;ul&gt;
&lt;li&gt;新生代 GC (Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度老年代 GC (Major GC/ Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK14新特性之-jpackage命令打包</title>
    <link href="http://example.com/2021/03/08/Jdk14%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjpackage%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85/"/>
    <id>http://example.com/2021/03/08/Jdk14%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjpackage%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.hacpai.com/bing/20171212.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"></p><h3 id="jpackage-命令帮助"><a href="#jpackage-命令帮助" class="headerlink" title="jpackage 命令帮助"></a>jpackage 命令帮助</h3><p>在 Jdk14 中，新增 jpackage 特性。借助 jpackage，可以在特定平台上以用户习惯的方式安装或卸载 Java 应用程序，并且，它支持 Windows 上的 msi 和 exe 格式、MacOS 上的 pkg 和 dmg 格式、Linux 上的 deb 和 rpm 格式。在安装用 jpackage 构建的应用程序时，最终用户应该不会注意到任何不同。进入 JDK 的 bin 目录，在该目录下打开 CMD 窗口，查看 jpackage 使用帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\jpackage --help</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">生成适合主机系统的应用程序包：</span><br><span class="line">    对于模块化应用程序：</span><br><span class="line">        jpackage -n name -p modulePath -m moduleName&#x2F;className</span><br><span class="line">    对于非模块化应用程序：</span><br><span class="line">        jpackage -i inputDir -n name \</span><br><span class="line">            --main-class className --main-jar myJar.jar</span><br><span class="line">    从预构建的应用程序映像：</span><br><span class="line">        jpackage -n name --app-image appImageDir</span><br><span class="line">生成应用程序映像：</span><br><span class="line">    对于模块化应用程序：</span><br><span class="line">        jpackage --type app-image -n name -p modulePath \</span><br><span class="line">            -m moduleName&#x2F;className</span><br><span class="line">    对于非模块化应用程序：</span><br><span class="line">        jpackage --type app-image -i inputDir -n name \</span><br><span class="line">            --main-class className --main-jar myJar.jar</span><br><span class="line">    要为 jlink 提供您自己的选项，请单独运行 jlink：</span><br><span class="line">        jlink --output appRuntimeImage -p modulePath -m moduleName \</span><br><span class="line">            --no-header-files [&lt;additional jlink options&gt;...]</span><br><span class="line">        jpackage --type app-image -n name \</span><br><span class="line">            -m moduleName&#x2F;className --runtime-image appRuntimeImage</span><br><span class="line">生成 Java 运行时程序包：</span><br><span class="line">    jpackage -n name --runtime-image &lt;runtime-image&gt;</span><br></pre></td></tr></table></figure><h3 id="实战（打包成-exe）："><a href="#实战（打包成-exe）：" class="headerlink" title="实战（打包成 exe）："></a>实战（打包成 exe）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\jpackage --type exe -i G:\project\demo1\target -n demo -d  G:\project\demo1\target --main-class com.example.demo.DemoApplication --main-jar demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>使用上打包命令报错。信息如下：</p><p><img src="https://img.hacpai.com/file/2020/03/image-08e067a4.png" title="image.png"></p><p>安装打包工具 wixtool。<a href="%22%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%22">https://wixtoolset.org/releases/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20171212.jpg?imageView2/1/w/960/h/540/interlace/1/q/100&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;jpackage-命令帮助&quot;&gt;&lt;a href=&quot;#jpackage-命令帮助&quot; class=&quot;headerlink&quot; title=&quot;jpackage 命令帮助&quot;&gt;&lt;/a&gt;jpackage 命令帮助&lt;/h3&gt;&lt;p&gt;在 Jdk14 中，新增 jpackage 特性。借助 jpackage，可以在特定平台上以用户习惯的方式安装或卸载 Java 应用程序，并且，它支持 Windows 上的 msi 和 exe 格式、MacOS 上的 pkg 和 dmg 格式、Linux 上的 deb 和 rpm 格式。在安装用 jpackage 构建的应用程序时，最终用户应该不会注意到任何不同。进入 JDK 的 bin 目录，在该目录下打开 CMD 窗口，查看 jpackage 使用帮助。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.\jpackage --help&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习笔记-命令行工具篇</title>
    <link href="http://example.com/2021/03/08/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%AF%87/"/>
    <id>http://example.com/2021/03/08/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%AF%87/</id>
    <published>2021-03-08T12:46:25.000Z</published>
    <updated>2021-04-12T02:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM学习笔记-命令行工具篇"><a href="#JVM学习笔记-命令行工具篇" class="headerlink" title="JVM学习笔记-命令行工具篇"></a>JVM学习笔记-命令行工具篇</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li>响应时间</li><li>吞吐量</li><li>并发数</li><li>内存占用</li></ul><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>作用：查看增在运行的java进程</p><p>参数：</p><ul><li> -q :仅仅显示LVMID(local virtual machine id),即本地虚拟机唯一ID，不显示类名称</li><li>-l: 输出应用程序主类的全类名</li><li>-v: 列出虚拟机进程启动时的JVM参数</li><li>-m 输出虚拟机进程启动传给主类main()的参数</li></ul><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>作用：查看JVM统计信息,常应用于检测垃圾回收问题和OOM。</p><p>命令格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure><ul><li>-t :  显示程序的运行时间，单位为秒。</li><li>interval:  指定输出统计数据的周期，单位为毫秒。</li><li>count: 用于指定统计的总次数</li><li>-h: 输出表头数据</li><li>vmid: 进程id(通过jps命令获取)</li></ul><p>option选项：</p><ul><li><p>-class: 显示classloader相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间</p></li><li><p>-gc: 显示gc相关的堆信息</p></li><li><p>-gccapacity:  输出信息主要与gc相同，但输出主要关注堆各个区域用到的最小和最大空间</p></li><li><p>-gcutil: 显示内容与gc基本相同，主要关注百分比</p></li><li><p>-gccause: 与gcutil功能一样，但会输出最后一次gc的原因</p></li><li><p>-gcnew: 显示新生代GC状况</p></li></ul><p>示例如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210308175912.png"></p><ul><li>SOC: 第一个幸存区大小，单位为字节</li><li>S1C: 第二次幸存区大小，单位为字节</li><li>S0U: 第一个幸存区已使用的大小，单位为字节</li><li>S1U: 第二个幸存区已使用的大小，单位为字节</li><li>EC: Eden空间的大小</li><li>EU: Eden已使用空间的大小</li><li>OC: 老年代的大小</li><li>OU：老年代已使用的大小</li><li>MC: 方法区的大小</li><li>MU: 方法区已使用的大小</li><li>CCSC: 压缩类空间的大小</li><li>CCSU: 压缩类已使用空间的大小</li><li>YGC: young gc次数</li><li>YGCT:  yong gc消耗的时间</li><li>FGC:  full gc次数</li><li>PGCT: full gc时间</li><li>GCT: 应用程序启动到采样gc总时间</li></ul><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>作用： 查看和修改JVM配置信息</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] &lt;pid&gt;</span><br><span class="line">       </span><br><span class="line">jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">      </span><br><span class="line">jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">jinfo -sysprops PID #查看由System.getProperties()取得的参数</span><br><span class="line"></span><br><span class="line">jinfo -flags PID  #查看曾经赋值得一些参数</span><br><span class="line"></span><br><span class="line">jinfo -flag 具体参数 PID #查看某个java进程的具体参数的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改</span><br><span class="line">jinfo -flag [+|-]具体参数 PID  ## boolean类型修改</span><br><span class="line"></span><br><span class="line">jinfo -flag 具体参数&#x3D;参数值 PID ##非boolean类型</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210308221020.png"></p><p><strong>只有标记为manageable的flag才可以被实时修改</strong>，查看manageable参数命令为 java –XX:+PrintFlagsFinal -version| grep manageable</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>作用：dump文件和获取堆内存使用情况</p><p>命令格式 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line"></span><br><span class="line">jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.手动导出内存映像文件  </span><br><span class="line"># format &#x3D;b表面格式与hprof对应起来，表面这是一个标准的格式</span><br><span class="line">jmap -dump:format&#x3D;b,file&#x3D;d:\1.hprof PID</span><br><span class="line"></span><br><span class="line">## live 只保存堆中存活的对象</span><br><span class="line">jmap -dump:live,format&#x3D;b,file&#x3D;d:\1.hprof PID</span><br><span class="line"></span><br><span class="line">2.OOM自动生成内存镜像文件</span><br><span class="line">设置JVM参数；</span><br><span class="line">-XX : +HeapDumpOnOutOfMemoryError:在程序发生00M时，导出应用程序的当前堆快照。</span><br><span class="line">-XX:HeapDumpPath:可以指定堆快照的保存位置。</span><br><span class="line"></span><br><span class="line">3.显示堆内存相关信息</span><br><span class="line">jmap -heap PID &gt;1.txt</span><br><span class="line"></span><br><span class="line">jmap -histo PID&gt;2.txt</span><br><span class="line"></span><br><span class="line">4.查看系统的ClassLoader信息</span><br><span class="line">jmap -permstat pid</span><br><span class="line"></span><br><span class="line">5.查看堆积在finalizer队列中的对象</span><br><span class="line">jmap -finalizerinfo </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</strong></p><p>实例如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210308225201.png"></p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>作用：dump分析工具。使用了jhat命令，就启动了一个http服务，端口是7000，即<a href="http://localhost:7000/%E3%80%82">http://localhost:7000/。</a> jhat命令在JDK9、JDK10中已经被删除，官方建议用Visua1VM代替，所以不详细学习。</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat filePath</span><br></pre></td></tr></table></figure><p>示例如下：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210308233608.png"></p><p>访问<a href="http://localhost:7000,如图">http://localhost:7000,如图</a></p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20210308225427.png"></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>作用:用于生成虚拟机指定进程当前时刻的线程快照(虚拟机堆栈跟踪)。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jstack [-l] &lt;pid&gt;</span><br><span class="line">jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br></pre></td></tr></table></figure><p>option参数</p><ul><li> -F :当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-l : 除堆栈外，显示关于锁的附加信息入</li><li>-m: 如果调用到本地方法的话，可以显示C/C++的堆栈</li><li>-h: 帮助操作</li></ul><h3 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h3><p>作用：它是一个多功能的工具，可以用来实现前面除了jstat之外所有命令的功能。比如:用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等,官方推荐使用jcmd代替其他命令。</p><p>常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.列出所有JVM进程</span><br><span class="line">jcmd -l </span><br><span class="line"></span><br><span class="line">2.查看指定PID支持的操作</span><br><span class="line">jcmd PID help </span><br><span class="line"></span><br><span class="line">3.jcmd操作</span><br><span class="line">jcmd PID 支持的操作</span><br></pre></td></tr></table></figure><p>示例演示：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/image-20210308232024256.png"></p><p>使用jcmd导出dump:</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/image-20210308232142211.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM学习笔记-命令行工具篇&quot;&gt;&lt;a href=&quot;#JVM学习笔记-命令行工具篇&quot; class=&quot;headerlink&quot; title=&quot;JVM学习笔记-命令行工具篇&quot;&gt;&lt;/a&gt;JVM学习笔记-命令行工具篇&lt;/h2&gt;&lt;h3 id=&quot;性能指标&quot;&gt;&lt;a href=&quot;#性</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
</feed>
